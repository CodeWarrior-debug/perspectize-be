---
phase: 01-foundation
plan: 05
type: execute
wave: 2
depends_on: ["01-03"]
files_modified:
  - fe/tests/setup.ts
  - fe/tests/helpers/render.ts
  - fe/tests/unit/utils.test.ts
  - fe/tests/unit/queries-client.test.ts
  - fe/tests/unit/queries-content.test.ts
  - fe/tests/unit/shadcn-barrel.test.ts
  - fe/tests/components/Header.test.ts
  - fe/tests/components/PageWrapper.test.ts
  - fe/tests/unit/example.test.ts
  - fe/vite.config.ts
autonomous: true

must_haves:
  truths:
    - "Running pnpm test:coverage shows >80% line coverage across all source files"
    - "All tests pass with pnpm test:run (zero failures)"
    - "cn() utility is tested with empty, single, multiple, and conflicting Tailwind classes"
    - "GraphQL client creation and environment variable override are tested"
    - "GraphQL query definitions export the expected query strings"
    - "Header component renders logo text and header element"
    - "PageWrapper component renders children and applies custom classes"
    - "Placeholder example.test.ts is replaced with real tests"
    - "Test helper for rendering Svelte 5 components exists and is reusable"
  artifacts:
    - path: "fe/tests/unit/utils.test.ts"
      provides: "Unit tests for cn() utility"
      contains: "cn("
      min_lines: 20
    - path: "fe/tests/unit/queries-client.test.ts"
      provides: "Unit tests for GraphQL client setup"
      contains: "graphqlClient"
      min_lines: 15
    - path: "fe/tests/unit/queries-content.test.ts"
      provides: "Unit tests for GraphQL query definitions"
      contains: "LIST_CONTENT"
      min_lines: 15
    - path: "fe/tests/components/Header.test.ts"
      provides: "Component tests for Header.svelte"
      contains: "Header"
      min_lines: 20
    - path: "fe/tests/components/PageWrapper.test.ts"
      provides: "Component tests for PageWrapper.svelte"
      contains: "PageWrapper"
      min_lines: 20
    - path: "fe/tests/helpers/render.ts"
      provides: "Shared test helpers for Svelte 5 component rendering"
      contains: "render"
      min_lines: 5
    - path: "fe/vite.config.ts"
      provides: "Vitest config with 80% coverage thresholds"
      contains: "thresholds"
  key_links:
    - from: "fe/tests/components/Header.test.ts"
      to: "fe/src/lib/components/Header.svelte"
      via: "import and render"
      pattern: "import.*Header"
    - from: "fe/tests/components/PageWrapper.test.ts"
      to: "fe/src/lib/components/PageWrapper.svelte"
      via: "import and render"
      pattern: "import.*PageWrapper"
    - from: "fe/tests/unit/utils.test.ts"
      to: "fe/src/lib/utils.ts"
      via: "import cn function"
      pattern: "import.*cn.*from"
---

<objective>
Add comprehensive test coverage (>80% line coverage) for all existing frontend source code and establish testing conventions/helpers that plans 01-04 and beyond will follow.

Purpose: The current test suite is a placeholder (1+1=2). This plan replaces it with real tests covering every source file, establishes reusable testing patterns for Svelte 5 components, and configures coverage thresholds to prevent regressions. This directly satisfies requirements TEST-01 and TEST-02.

Output: A test suite with >80% line coverage, shared test helpers, organized test directories (tests/unit/ and tests/components/), and coverage thresholds enforced in vite.config.ts.
</objective>

<execution_context>
@/Users/jamesjordan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesjordan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test helpers and unit tests for pure modules</name>
  <files>
    fe/tests/helpers/render.ts
    fe/tests/unit/utils.test.ts
    fe/tests/unit/queries-client.test.ts
    fe/tests/unit/queries-content.test.ts
    fe/tests/unit/shadcn-barrel.test.ts
    fe/tests/unit/example.test.ts
  </files>
  <action>
    **Step 1: Create shared test helper for Svelte 5 component rendering.**

    Create `tests/helpers/render.ts`:
    ```typescript
    import { render, type RenderResult } from '@testing-library/svelte';
    import type { Component } from 'svelte';

    /**
     * Render a Svelte 5 component for testing.
     * Wraps @testing-library/svelte render with project conventions.
     *
     * Usage:
     *   import { renderComponent } from '../helpers/render';
     *   const { getByText } = renderComponent(MyComponent, { someProp: 'value' });
     *
     * For components with children/slots, use @testing-library/svelte render directly
     * since Svelte 5 snippet slots require special handling.
     */
    export function renderComponent<T extends Record<string, any>>(
      component: Component<T>,
      props?: Partial<T>
    ): RenderResult<Component<T>> {
      return render(component, { props: props as T });
    }

    /**
     * Helper to assert an element has specific Tailwind classes.
     * Useful for verifying responsive/layout classes without full CSS rendering.
     */
    export function expectClasses(element: HTMLElement, ...classes: string[]) {
      for (const cls of classes) {
        expect(element.classList.contains(cls)).toBe(true);
      }
    }
    ```

    This helper establishes conventions:
    - `renderComponent()` is the standard way to render Svelte 5 components in tests
    - `expectClasses()` is a utility for checking Tailwind class application
    - Future plans (01-04+) import from `../helpers/render` for consistency

    **Step 2: Delete the placeholder example.test.ts and replace it.**

    Delete the contents of `tests/unit/example.test.ts` entirely (the file can be removed or replaced). It currently has `1+1=2` which provides no value.

    **Step 3: Create `tests/unit/utils.test.ts` for the cn() utility.**

    ```typescript
    import { describe, it, expect } from 'vitest';
    import { cn } from '$lib/utils';

    describe('cn() utility', () => {
      it('returns empty string for no arguments', () => {
        expect(cn()).toBe('');
      });

      it('passes through a single class', () => {
        expect(cn('text-red-500')).toBe('text-red-500');
      });

      it('merges multiple classes', () => {
        const result = cn('px-4', 'py-2', 'text-sm');
        expect(result).toContain('px-4');
        expect(result).toContain('py-2');
        expect(result).toContain('text-sm');
      });

      it('handles conditional classes via clsx', () => {
        const isActive = true;
        const result = cn('base', isActive && 'active');
        expect(result).toContain('base');
        expect(result).toContain('active');
      });

      it('removes falsy conditional classes', () => {
        const isActive = false;
        const result = cn('base', isActive && 'active');
        expect(result).toBe('base');
        expect(result).not.toContain('active');
      });

      it('resolves conflicting Tailwind classes (last wins via twMerge)', () => {
        // twMerge deduplicates conflicting utilities
        const result = cn('px-4', 'px-8');
        expect(result).toBe('px-8');
        expect(result).not.toContain('px-4');
      });

      it('handles undefined and null inputs', () => {
        const result = cn('text-sm', undefined, null, 'font-bold');
        expect(result).toContain('text-sm');
        expect(result).toContain('font-bold');
      });

      it('merges object syntax from clsx', () => {
        const result = cn({ 'text-red-500': true, 'text-blue-500': false });
        expect(result).toBe('text-red-500');
      });

      it('merges array syntax from clsx', () => {
        const result = cn(['px-4', 'py-2']);
        expect(result).toContain('px-4');
        expect(result).toContain('py-2');
      });
    });
    ```

    **Step 4: Create `tests/unit/queries-client.test.ts` for GraphQL client.**

    ```typescript
    import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

    describe('GraphQL client', () => {
      // We need to test the module-level client creation.
      // Use dynamic import to get fresh module per test when needed.

      it('exports a graphqlClient instance', async () => {
        const { graphqlClient } = await import('$lib/queries/client');
        expect(graphqlClient).toBeDefined();
        expect(typeof graphqlClient.request).toBe('function');
      });

      it('client has request method for making GraphQL calls', async () => {
        const { graphqlClient } = await import('$lib/queries/client');
        // graphql-request GraphQLClient exposes request, rawRequest, batchRequests
        expect(graphqlClient).toHaveProperty('request');
        expect(graphqlClient).toHaveProperty('rawRequest');
      });

      it('uses default endpoint when VITE_GRAPHQL_URL is not set', async () => {
        // The default is http://localhost:8080/graphql
        // We verify the client is created (module-level) without errors
        const { graphqlClient } = await import('$lib/queries/client');
        expect(graphqlClient).toBeDefined();
      });
    });
    ```

    NOTE: Testing `import.meta.env` overrides in Vitest requires `vi.stubEnv()` which has limitations with module-level evaluation. The tests above verify the client is properly created and functional. Do NOT attempt to re-import the module with different env vars (module caching makes this unreliable without `vi.resetModules()` complexity). Keep these tests simple and focused on exports.

    **Step 5: Create `tests/unit/queries-content.test.ts` for query definitions.**

    ```typescript
    import { describe, it, expect } from 'vitest';
    import { LIST_CONTENT, GET_CONTENT } from '$lib/queries/content';

    describe('GraphQL query definitions', () => {
      describe('LIST_CONTENT', () => {
        it('is defined and is a string', () => {
          expect(LIST_CONTENT).toBeDefined();
          expect(typeof LIST_CONTENT).toBe('string');
        });

        it('contains the ListContent operation name', () => {
          expect(LIST_CONTENT).toContain('ListContent');
        });

        it('queries content with pagination params', () => {
          expect(LIST_CONTENT).toContain('$first: Int');
          expect(LIST_CONTENT).toContain('$after: String');
        });

        it('requests expected content fields', () => {
          expect(LIST_CONTENT).toContain('id');
          expect(LIST_CONTENT).toContain('name');
          expect(LIST_CONTENT).toContain('url');
          expect(LIST_CONTENT).toContain('contentType');
          expect(LIST_CONTENT).toContain('createdAt');
          expect(LIST_CONTENT).toContain('updatedAt');
        });

        it('includes pageInfo for cursor pagination', () => {
          expect(LIST_CONTENT).toContain('pageInfo');
          expect(LIST_CONTENT).toContain('hasNextPage');
          expect(LIST_CONTENT).toContain('endCursor');
        });

        it('includes totalCount', () => {
          expect(LIST_CONTENT).toContain('totalCount');
        });
      });

      describe('GET_CONTENT', () => {
        it('is defined and is a string', () => {
          expect(GET_CONTENT).toBeDefined();
          expect(typeof GET_CONTENT).toBe('string');
        });

        it('contains the GetContent operation name', () => {
          expect(GET_CONTENT).toContain('GetContent');
        });

        it('takes an id parameter', () => {
          expect(GET_CONTENT).toContain('$id: ID!');
        });

        it('uses contentByID query', () => {
          expect(GET_CONTENT).toContain('contentByID');
        });

        it('requests detailed content fields', () => {
          expect(GET_CONTENT).toContain('length');
          expect(GET_CONTENT).toContain('viewCount');
          expect(GET_CONTENT).toContain('likeCount');
          expect(GET_CONTENT).toContain('commentCount');
          expect(GET_CONTENT).toContain('response');
        });
      });
    });
    ```

    **Step 6: Create `tests/unit/shadcn-barrel.test.ts` for barrel export verification.**

    ```typescript
    import { describe, it, expect } from 'vitest';
    import { Button, buttonVariants } from '$lib/components/shadcn';

    describe('shadcn barrel exports', () => {
      it('exports Button component', () => {
        expect(Button).toBeDefined();
      });

      it('exports buttonVariants function', () => {
        expect(buttonVariants).toBeDefined();
        expect(typeof buttonVariants).toBe('function');
      });

      it('buttonVariants returns class string for default variant', () => {
        const classes = buttonVariants({ variant: 'default' });
        expect(typeof classes).toBe('string');
        expect(classes.length).toBeGreaterThan(0);
      });

      it('buttonVariants returns different classes for different variants', () => {
        const defaultClasses = buttonVariants({ variant: 'default' });
        const outlineClasses = buttonVariants({ variant: 'outline' });
        expect(defaultClasses).not.toBe(outlineClasses);
      });
    });
    ```

    NOTE: We test the barrel exports and buttonVariants function, NOT the auto-generated button.svelte component. buttonVariants is a tailwind-variants function that returns class strings -- this is pure logic worth testing.

    NOTE: `layout-config.test.ts` is intentionally NOT created. The `+layout.ts` file lives under `src/routes/` which is excluded from coverage via the `src/routes/**` exclusion. Route files are integration-level and will be tested in Phase 5 via E2E. Creating a unit test for excluded code is contradictory.
  </action>
  <verify>
    Run all unit tests:
    ```bash
    cd fe && pnpm test:run -- tests/unit/
    ```
    All tests pass with zero failures.

    Verify placeholder test is gone:
    ```bash
    grep -r "1 + 1" fe/tests/
    ```
    No results (placeholder removed).

    Verify test helper exists:
    ```bash
    test -f fe/tests/helpers/render.ts && echo "exists"
    ```
  </verify>
  <done>
    - tests/helpers/render.ts created with renderComponent() and expectClasses() helpers
    - tests/unit/utils.test.ts covers cn() with 9+ test cases (empty, single, multi, conditional, falsy, conflicts, undefined/null, object syntax, array syntax)
    - tests/unit/queries-client.test.ts verifies GraphQL client exports and methods
    - tests/unit/queries-content.test.ts verifies LIST_CONTENT and GET_CONTENT query structure and fields
    - tests/unit/shadcn-barrel.test.ts verifies barrel exports and buttonVariants behavior
    - layout-config.test.ts intentionally omitted (src/routes/** excluded from coverage; route testing deferred to Phase 5)
    - Placeholder example.test.ts deleted or replaced
    - All unit tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Svelte component tests and configure coverage thresholds</name>
  <files>
    fe/tests/components/Header.test.ts
    fe/tests/components/PageWrapper.test.ts
    fe/vite.config.ts
    fe/tests/setup.ts
  </files>
  <action>
    **Step 1: Update tests/setup.ts to add mocks needed for component tests.**

    The existing setup.ts has mocks for `$app/environment` and `$app/navigation`. Add a mock for `$app/stores` which some components may import transitively, and add a mock for `$lib/assets/favicon.svg` which +layout.svelte imports:

    ```typescript
    import '@testing-library/jest-dom/vitest';
    import { vi } from 'vitest';
    import { readable } from 'svelte/store';

    // Mock $app/environment for tests
    vi.mock('$app/environment', () => ({
      browser: true,
      dev: true,
      building: false
    }));

    // Mock $app/navigation if needed
    vi.mock('$app/navigation', () => ({
      goto: vi.fn(),
      invalidate: vi.fn(),
      invalidateAll: vi.fn(),
      preloadData: vi.fn(),
      preloadCode: vi.fn(),
      afterNavigate: vi.fn(),
      beforeNavigate: vi.fn()
    }));

    // Mock $app/stores for components that access page store
    // NOTE: `readable` is imported at top level (NOT inside the factory).
    // vi.mock factories are hoisted and do NOT reliably support top-level await.
    vi.mock('$app/stores', () => {
      return {
        page: readable({
          url: new URL('http://localhost'),
          params: {},
          route: { id: '/' },
          status: 200,
          error: null,
          data: {},
          form: null,
        }),
        navigating: readable(null),
        updated: { check: vi.fn(), subscribe: readable(false).subscribe },
      };
    });

    // Mock asset imports (SVG files imported as URLs by Vite)
    vi.mock('$lib/assets/favicon.svg', () => ({
      default: '/favicon.svg'
    }));
    ```

    IMPORTANT: `readable` is imported at the top of the file (`import { readable } from 'svelte/store'`), NOT inside the `vi.mock()` factory function. vi.mock factories are hoisted to the top of the file by Vitest and do NOT reliably support `await import()` or other async operations inside the factory. The top-level import is available because vi.mock hoisting happens after all static imports.

    **Step 2: Create `tests/components/Header.test.ts`.**

    ```typescript
    import { describe, it, expect } from 'vitest';
    import { render, screen } from '@testing-library/svelte';
    import Header from '$lib/components/Header.svelte';

    describe('Header component', () => {
      it('renders without errors', () => {
        render(Header);
        // Should not throw
      });

      it('renders the Perspectize brand name', () => {
        render(Header);
        expect(screen.getByText('Perspectize')).toBeInTheDocument();
      });

      it('renders a header element', () => {
        const { container } = render(Header);
        const header = container.querySelector('header');
        expect(header).toBeInTheDocument();
      });

      it('header has fixed height class (h-16)', () => {
        const { container } = render(Header);
        const header = container.querySelector('header');
        expect(header?.className).toContain('h-16');
      });

      it('header has bottom border', () => {
        const { container } = render(Header);
        const header = container.querySelector('header');
        expect(header?.className).toContain('border-b');
      });

      it('contains a nav element for navigation links', () => {
        const { container } = render(Header);
        const nav = container.querySelector('nav');
        expect(nav).toBeInTheDocument();
      });

      it('has responsive padding classes on inner container', () => {
        const { container } = render(Header);
        const inner = container.querySelector('header > div');
        expect(inner?.className).toContain('px-4');
        expect(inner?.className).toContain('md:px-6');
        expect(inner?.className).toContain('lg:px-8');
      });

      it('has max-width constraint for large screens', () => {
        const { container } = render(Header);
        const inner = container.querySelector('header > div');
        expect(inner?.className).toContain('max-w-screen-xl');
      });
    });
    ```

    NOTE: We do NOT test the nav slot content (it is empty until 01-04 adds navigation). We test the structural elements that exist now. Svelte 5 slot testing with @testing-library/svelte requires special snippet handling which is not needed here since we are testing the component itself, not its slot consumers.

    **Step 3: Create `tests/components/PageWrapper.test.ts`.**

    PageWrapper uses `{@render children()}` which is a REQUIRED prop in Svelte 5 -- calling `render(PageWrapper)` without providing `children` will throw because `children` is destructured from `$props()` without a default, and `{@render children()}` calls it unconditionally.

    To test PageWrapper, provide a children snippet. `@testing-library/svelte` v5+ supports Svelte 5 snippets. If the version in use does not support passing children directly, create a thin wrapper component.

    **Approach A (preferred -- direct children via @testing-library/svelte v5):**

    ```typescript
    import { describe, it, expect } from 'vitest';
    import { render } from '@testing-library/svelte';
    import PageWrapper from '$lib/components/PageWrapper.svelte';
    import { createRawSnippet } from 'svelte';

    // Create a reusable children snippet for testing
    function createChildrenSnippet(text: string = 'Test content') {
      return createRawSnippet(() => ({
        render: () => `<span>${text}</span>`,
      }));
    }

    describe('PageWrapper component', () => {
      it('renders a main element with children', () => {
        const { container } = render(PageWrapper, {
          props: { children: createChildrenSnippet() },
        });
        const main = container.querySelector('main');
        expect(main).toBeInTheDocument();
      });

      it('renders the provided children content', () => {
        const { container } = render(PageWrapper, {
          props: { children: createChildrenSnippet('Hello World') },
        });
        expect(container.textContent).toContain('Hello World');
      });

      it('has responsive padding classes', () => {
        const { container } = render(PageWrapper, {
          props: { children: createChildrenSnippet() },
        });
        const main = container.querySelector('main');
        expect(main?.className).toContain('px-4');
        expect(main?.className).toContain('py-6');
        expect(main?.className).toContain('md:px-6');
        expect(main?.className).toContain('md:py-8');
        expect(main?.className).toContain('lg:px-8');
      });

      it('has max-width constraint', () => {
        const { container } = render(PageWrapper, {
          props: { children: createChildrenSnippet() },
        });
        const main = container.querySelector('main');
        expect(main?.className).toContain('max-w-screen-xl');
      });

      it('applies custom className when provided', () => {
        const { container } = render(PageWrapper, {
          props: { class: 'custom-class', children: createChildrenSnippet() },
        });
        const main = container.querySelector('main');
        expect(main?.className).toContain('custom-class');
      });

      it('applies empty className by default', () => {
        const { container } = render(PageWrapper, {
          props: { children: createChildrenSnippet() },
        });
        const main = container.querySelector('main');
        // Default className is '' which results in base classes only
        expect(main?.className).toContain('px-4');
      });
    });
    ```

    **Approach B (fallback -- if createRawSnippet is not available in the installed Svelte version):**

    Create a wrapper test component at `tests/components/_PageWrapperTest.svelte`:
    ```svelte
    <script lang="ts">
      import PageWrapper from '$lib/components/PageWrapper.svelte';
      let { testClass = '' } = $props();
    </script>
    <PageWrapper class={testClass}>
      <span data-testid="child-content">Test content</span>
    </PageWrapper>
    ```

    Then test via the wrapper:
    ```typescript
    import { render } from '@testing-library/svelte';
    import PageWrapperTest from './_PageWrapperTest.svelte';

    it('renders children inside main', () => {
      const { getByTestId } = render(PageWrapperTest);
      expect(getByTestId('child-content')).toBeInTheDocument();
    });
    ```

    The executor should try Approach A first. If `createRawSnippet` is unavailable or errors, fall back to Approach B with the wrapper component.

    **Step 4: Configure coverage thresholds in vite.config.ts.**

    Update the `coverage` section in `vite.config.ts` to enforce 80% thresholds:

    ```typescript
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        '.svelte-kit/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/setup.ts',
        // Exclude shadcn auto-generated components (third-party)
        'src/lib/components/shadcn/button/button.svelte',
        // Exclude route pages from coverage (tested via integration/E2E in Phase 5)
        'src/routes/**',
      ],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 80,
        statements: 80,
      },
    },
    ```

    The `thresholds` block makes `pnpm test:coverage` FAIL if coverage drops below 80%, preventing regressions. This is the enforcement mechanism.

    The `exclude` additions:
    - `src/lib/components/shadcn/button/button.svelte` -- auto-generated by shadcn CLI, not our code, should not count toward coverage
    - `src/routes/**` -- route pages (+page.svelte, +layout.svelte, +layout.ts) are integration-level; they contain mostly markup and framework wiring. Testing them with unit tests creates brittle mocks of QueryClientProvider, Toaster, etc. They will be tested via E2E in Phase 5.

    NOTE: Do NOT exclude barrel files (shadcn/index.ts, button/index.ts) from coverage -- those are tested in shadcn-barrel.test.ts.

    **Step 5: Run full test suite with coverage and verify.**

    After creating all test files, run:
    ```bash
    cd fe && pnpm test:coverage
    ```

    Review the coverage output. If any source file is below 80%:
    1. Check which lines are uncovered
    2. Add targeted tests to cover those lines
    3. Re-run coverage

    The goal is >80% line coverage on all NON-excluded files. If specific files are stubbornly low due to framework internals (e.g., Svelte component lifecycle code that only runs in browser), add them to coverage.exclude with a comment explaining why.
  </action>
  <verify>
    Run full test suite:
    ```bash
    cd fe && pnpm test:run
    ```
    All tests pass (zero failures).

    Run coverage check:
    ```bash
    cd fe && pnpm test:coverage
    ```
    Coverage report shows >80% lines across all included source files. Coverage thresholds pass (exit code 0).

    Verify thresholds are enforced:
    ```bash
    grep -q "thresholds" fe/vite.config.ts && echo "thresholds configured"
    ```

    Verify test organization:
    ```bash
    ls fe/tests/unit/ fe/tests/components/ fe/tests/helpers/
    ```
    Expected: unit/ has utils, queries-client, queries-content, shadcn-barrel test files. components/ has Header, PageWrapper test files. helpers/ has render.ts.
  </verify>
  <done>
    - tests/components/Header.test.ts covers rendering, brand text, structure, responsive classes, nav element
    - tests/components/PageWrapper.test.ts covers rendering with children snippet, main element, responsive classes, custom className prop
    - vite.config.ts has coverage thresholds at 80% (lines, functions, branches, statements)
    - shadcn button.svelte excluded from coverage (auto-generated third-party)
    - Route pages excluded from coverage (integration-level, tested in Phase 5)
    - tests/setup.ts updated with $app/stores mock (using top-level readable import) and favicon mock for component tests
    - Full suite passes with >80% coverage
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **All tests pass**: `pnpm test:run` exits with 0 failures
2. **Coverage threshold met**: `pnpm test:coverage` exits with code 0 (thresholds enforced)
3. **Coverage >80%**: Text output shows >80% line coverage on all included files
4. **Placeholder gone**: No `1 + 1` test exists in the codebase
5. **Test organization**: tests/unit/ for pure modules, tests/components/ for Svelte, tests/helpers/ for shared utilities
6. **Conventions established**: renderComponent helper, naming pattern ({module}.test.ts), directory structure documented by example
</verification>

<success_criteria>
- pnpm test:run passes with 0 failures across all test files
- pnpm test:coverage shows >80% line coverage (enforced by thresholds)
- cn() tested with 9+ cases covering empty, single, multi, conditional, falsy, conflicting, undefined/null, object, array
- GraphQL client exports and methods verified
- LIST_CONTENT and GET_CONTENT query structure and fields verified
- shadcn barrel exports and buttonVariants behavior verified
- Header component renders brand text, header element, nav element, responsive classes
- PageWrapper component renders with children snippet, main element, responsive classes, custom className prop
- Placeholder example.test.ts removed
- Test helper renderComponent() available in tests/helpers/render.ts
- Coverage thresholds (80%) configured in vite.config.ts
- shadcn button.svelte excluded from coverage metrics
- Route pages excluded from coverage (integration-level testing deferred to Phase 5)
- $app/stores mock uses top-level `readable` import (not await import inside vi.mock factory)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
