---
phase: 02-data-layer-activity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/schema.graphql
  - backend/internal/core/ports/repositories/user_repository.go
  - backend/internal/adapters/repositories/postgres/user_repository.go
  - backend/internal/core/services/user_service.go
  - backend/internal/adapters/graphql/resolvers/schema.resolvers.go
  - backend/internal/adapters/graphql/generated/generated.go
  - backend/internal/adapters/graphql/model/models_gen.go
  - fe/src/lib/queries/content.ts
  - fe/src/lib/queries/users.ts
  - fe/src/lib/stores/userSelection.svelte.ts
  - fe/tests/unit/queries-users.test.ts
  - fe/tests/unit/queries-content.test.ts
  - fe/tests/unit/stores-userSelection.test.ts
autonomous: true

must_haves:
  truths:
    - "Backend returns a list of all users via GraphQL `users` query"
    - "Frontend can fetch content sorted by UPDATED_AT descending with totalCount"
    - "Frontend can fetch all users for dropdown population"
    - "Selected user ID persists in session storage across page navigation"
    - "Selected user ID loads from session storage on page load"
  artifacts:
    - path: "backend/schema.graphql"
      provides: "users list query definition"
      contains: "users:"
    - path: "fe/src/lib/queries/users.ts"
      provides: "GraphQL user query definitions"
      exports: ["LIST_USERS"]
      min_lines: 10
    - path: "fe/src/lib/queries/content.ts"
      provides: "Updated content query with sort params and additional fields"
      exports: ["LIST_CONTENT", "GET_CONTENT"]
      min_lines: 20
    - path: "fe/src/lib/stores/userSelection.svelte.ts"
      provides: "Reactive user selection state with session persistence"
      min_lines: 15
    - path: "fe/tests/unit/queries-users.test.ts"
      provides: "Unit tests for user queries"
      min_lines: 15
    - path: "fe/tests/unit/stores-userSelection.test.ts"
      provides: "Unit tests for user selection store"
      min_lines: 20
  key_links:
    - from: "fe/src/lib/queries/users.ts"
      to: "backend/schema.graphql"
      via: "GraphQL query matching schema"
      pattern: "users"
    - from: "fe/src/lib/stores/userSelection.svelte.ts"
      to: "sessionStorage"
      via: "$effect sync with browser guard"
      pattern: "sessionStorage"
    - from: "backend/internal/adapters/graphql/resolvers/schema.resolvers.go"
      to: "backend/internal/core/services/user_service.go"
      via: "resolver calls service.ListAll"
      pattern: "ListAll"
---

<objective>
Build the data layer foundation for Phase 2: add the missing `users` list query to the Go backend, create frontend GraphQL query definitions for users and updated content queries, and implement the user selection store with session storage persistence.

Purpose: The Activity page (Plan 02-02) needs three data sources: content list (sorted by updatedAt), users list (for dropdown), and persisted user selection. This plan provides all three without any UI work.

Output: Backend `users` query working end-to-end, frontend query files ready for TanStack Query consumption, user selection store with session persistence and tests.
</objective>

<execution_context>
@/Users/jamesjordan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesjordan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-layer-activity/02-RESEARCH.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

Key existing files:
@backend/schema.graphql
@backend/gqlgen.yml
@backend/internal/core/ports/repositories/user_repository.go
@backend/internal/adapters/repositories/postgres/user_repository.go
@backend/internal/core/services/user_service.go
@backend/internal/adapters/graphql/resolvers/resolver.go
@backend/internal/adapters/graphql/resolvers/schema.resolvers.go
@fe/src/lib/queries/client.ts
@fe/src/lib/queries/content.ts
@fe/tests/setup.ts
@fe/vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add users list query to Go backend</name>
  <files>
    backend/schema.graphql
    backend/internal/core/ports/repositories/user_repository.go
    backend/internal/adapters/repositories/postgres/user_repository.go
    backend/internal/core/services/user_service.go
    backend/internal/adapters/graphql/resolvers/schema.resolvers.go
    backend/internal/adapters/graphql/generated/generated.go
    backend/internal/adapters/graphql/model/models_gen.go
  </files>
  <action>
    Add a `users: [User!]!` query to the GraphQL schema and implement it through the full hexagonal architecture stack.

    **Step 1 - Schema:** Add `users: [User!]!` to the Query type in `schema.graphql` (after the existing `userByUsername` query). No pagination needed — v1 has a small user set.

    **Step 2 - Repository port:** Add `ListAll(ctx context.Context) ([]*domain.User, error)` method to the `UserRepository` interface in `internal/core/ports/repositories/user_repository.go`.

    **Step 3 - Repository implementation:** Add `ListAll` method to the PostgreSQL user repository in `internal/adapters/repositories/postgres/user_repository.go`. Query: `SELECT id, username, email, created_at, updated_at FROM users ORDER BY username ASC`. Use `sqlx.SelectContext` to scan into `[]userRow`, then convert each row via `userRowToDomain`. Return empty slice (not nil) if no users found.

    **Step 4 - Service:** Add `ListAll(ctx context.Context) ([]*domain.User, error)` method to `UserService` in `internal/core/services/user_service.go`. Simple delegation to `s.repo.ListAll(ctx)` with error wrapping: `fmt.Errorf("failed to list users: %w", err)`.

    **Step 5 - Code generation:** Run `make graphql-gen` from the `backend/` directory. This will add the `Users` method signature to the generated `QueryResolver` interface.

    **Step 6 - Resolver:** Implement the generated `Users` resolver method in `schema.resolvers.go`. Follow the existing `UserByID` pattern: call `r.UserService.ListAll(ctx)`, convert each `*domain.User` to `*model.User` using the existing conversion pattern (check how `UserByID` converts — it maps ID to string via `strconv.Itoa`, formats timestamps with `time.RFC3339`). Return the `[]*model.User` slice.

    **Step 7 - Verify:** Run `make test` from `backend/` to ensure all existing tests still pass (78+ tests). The new `ListAll` method won't have its own test yet — that's fine for v1 scope.

    **Important:** Do NOT modify `resolver.go` (the dependency injection file) — it already has `UserService` wired. Do NOT add pagination — simple list query is sufficient for the small user dataset.
  </action>
  <verify>
    Run from backend/:
    1. `make graphql-gen` succeeds without errors
    2. `make test` passes (all 78+ existing tests)
    3. `go build ./...` compiles without errors
    4. grep confirms `users:` query exists in schema.graphql
    5. grep confirms `ListAll` exists in user_repository.go (port), user_repository.go (postgres), and user_service.go
  </verify>
  <done>Backend compiles, all tests pass, `users: [User!]!` query exists in schema and is fully implemented through repository -> service -> resolver chain.</done>
</task>

<task type="auto">
  <name>Task 2: Frontend query definitions and user selection store</name>
  <files>
    fe/src/lib/queries/users.ts
    fe/src/lib/queries/content.ts
    fe/src/lib/stores/userSelection.svelte.ts
  </files>
  <action>
    Create frontend data layer files: user queries, updated content query, and user selection store.

    **File 1 - `src/lib/queries/users.ts`:**
    Create a new query file following the existing pattern in `content.ts`. Define:
    ```typescript
    import { gql } from 'graphql-request';

    export const LIST_USERS = gql`
      query ListUsers {
        users {
          id
          username
          email
        }
      }
    `;
    ```
    Keep it minimal — we only need id, username, and email for the dropdown.

    **File 2 - Update `src/lib/queries/content.ts`:**
    Update the existing `LIST_CONTENT` query to:
    1. Add `sortBy` and `sortOrder` parameters (for AG Grid column sorting): `$sortBy: ContentSortBy = UPDATED_AT, $sortOrder: SortOrder = DESC`
    2. Add `includeTotalCount: true` (needed for pagination display)
    3. Keep `$first: Int` and `$after: String` parameters
    4. Add `length` and `lengthUnits` to the items selection (needed for duration column)
    5. Pass all variables through: `content(first: $first, after: $after, sortBy: $sortBy, sortOrder: $sortOrder, includeTotalCount: $includeTotalCount)`

    Updated query shape:
    ```graphql
    query ListContent($first: Int, $after: String, $sortBy: ContentSortBy = UPDATED_AT, $sortOrder: SortOrder = DESC, $includeTotalCount: Boolean = true) {
      content(first: $first, after: $after, sortBy: $sortBy, sortOrder: $sortOrder, includeTotalCount: $includeTotalCount) {
        items {
          id
          name
          url
          contentType
          length
          lengthUnits
          createdAt
          updatedAt
        }
        pageInfo {
          hasNextPage
          endCursor
        }
        totalCount
      }
    }
    ```
    Keep `GET_CONTENT` query unchanged.

    **File 3 - `src/lib/stores/userSelection.svelte.ts`:**
    Create a Svelte 5 runes-based store with session storage persistence. Follow the pattern from 02-RESEARCH.md exactly:

    ```typescript
    import { browser } from '$app/environment';

    const STORAGE_KEY = 'perspectize:selectedUserId';

    function loadFromSession(): number | null {
      if (!browser) return null;
      const stored = sessionStorage.getItem(STORAGE_KEY);
      if (!stored) return null;
      const parsed = parseInt(stored, 10);
      return Number.isNaN(parsed) ? null : parsed;
    }

    // Exported reactive state — import and use directly in components
    export let selectedUserId = $state<number | null>(loadFromSession());

    // Auto-sync to session storage when value changes
    if (browser) {
      $effect(() => {
        if (selectedUserId !== null) {
          sessionStorage.setItem(STORAGE_KEY, String(selectedUserId));
        } else {
          sessionStorage.removeItem(STORAGE_KEY);
        }
      });
    }

    // Helper to clear selection
    export function clearUserSelection(): void {
      selectedUserId = null;
    }
    ```

    **Important:**
    - Use `perspectize:selectedUserId` as the storage key (namespaced to avoid conflicts)
    - Guard ALL sessionStorage access with `if (!browser)` check
    - Parse stored value with `parseInt` and validate with `Number.isNaN` (handle corrupted storage gracefully)
    - Export `clearUserSelection` helper for logout/reset scenarios
    - Create `src/lib/stores/` directory if it doesn't exist
  </action>
  <verify>
    1. `pnpm run check` passes (TypeScript/Svelte type checking) from fe/
    2. Verify files exist: `ls src/lib/queries/users.ts src/lib/stores/userSelection.svelte.ts`
    3. grep confirms `LIST_USERS` export in users.ts
    4. grep confirms `sortBy` parameter in content.ts LIST_CONTENT query
    5. grep confirms `sessionStorage` usage in userSelection.svelte.ts
  </verify>
  <done>Three frontend data layer files created: users.ts query (LIST_USERS), updated content.ts query (with sort/pagination params), and userSelection.svelte.ts store (with session persistence). All pass type checking.</done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for frontend data layer</name>
  <files>
    fe/tests/unit/queries-users.test.ts
    fe/tests/unit/queries-content.test.ts
    fe/tests/unit/stores-userSelection.test.ts
  </files>
  <action>
    Write unit tests for all new frontend data layer code, following established patterns in existing test files.

    **File 1 - `tests/unit/queries-users.test.ts`:**
    Follow the pattern in `queries-content.test.ts`. Test:
    - `LIST_USERS` is exported and is a string (gql template literal)
    - `LIST_USERS` contains expected GraphQL fields: `users`, `id`, `username`, `email`
    - `LIST_USERS` does NOT request unnecessary fields (e.g., `createdAt`, `updatedAt`)

    **File 2 - Update `tests/unit/queries-content.test.ts`:**
    The existing test file tests the content queries. Update/add tests for:
    - `LIST_CONTENT` contains `sortBy` variable definition
    - `LIST_CONTENT` contains `sortOrder` variable definition
    - `LIST_CONTENT` contains `includeTotalCount` variable definition
    - `LIST_CONTENT` requests `length` and `lengthUnits` fields
    - Existing tests for `LIST_CONTENT` and `GET_CONTENT` still pass

    **File 3 - `tests/unit/stores-userSelection.test.ts`:**
    Test the user selection store behavior. This is trickier because it uses Svelte 5 runes ($state, $effect) which require special handling in tests.

    Approach: Since .svelte.ts files use runes that are compiled by Svelte, test the store through its exported API. Mock sessionStorage in jsdom:

    ```typescript
    import { describe, it, expect, beforeEach, vi } from 'vitest';

    describe('userSelection store', () => {
      beforeEach(() => {
        // Clear session storage before each test
        sessionStorage.clear();
        // Reset modules to re-initialize store state
        vi.resetModules();
      });

      it('exports selectedUserId', async () => {
        const store = await import('$lib/stores/userSelection.svelte');
        // Initial value should be null (no session storage value)
        expect(store.selectedUserId).toBeNull();
      });

      it('exports clearUserSelection function', async () => {
        const store = await import('$lib/stores/userSelection.svelte');
        expect(typeof store.clearUserSelection).toBe('function');
      });

      it('loads stored user ID from session storage', async () => {
        sessionStorage.setItem('perspectize:selectedUserId', '42');
        const store = await import('$lib/stores/userSelection.svelte');
        expect(store.selectedUserId).toBe(42);
      });

      it('returns null for invalid session storage value', async () => {
        sessionStorage.setItem('perspectize:selectedUserId', 'not-a-number');
        const store = await import('$lib/stores/userSelection.svelte');
        expect(store.selectedUserId).toBeNull();
      });

      it('returns null when session storage is empty', async () => {
        const store = await import('$lib/stores/userSelection.svelte');
        expect(store.selectedUserId).toBeNull();
      });
    });
    ```

    **Note:** Use dynamic `import()` with `vi.resetModules()` to get fresh store state per test, since the store initializes on import. The jsdom environment in vitest provides sessionStorage automatically. If Svelte rune compilation causes issues with direct store testing, test the loadFromSession logic indirectly through the import behavior.

    **Important:**
    - Follow existing test file naming convention: `queries-users.test.ts`, `stores-userSelection.test.ts`
    - Use `describe`/`it` blocks matching existing test style
    - Run `pnpm test:run` to verify all tests pass (both new and existing)
  </action>
  <verify>
    1. `pnpm test:run` passes from fe/ (all tests including new ones)
    2. New test files exist: `ls tests/unit/queries-users.test.ts tests/unit/stores-userSelection.test.ts`
    3. Test count increased (was 42 tests across 6 files, should now be ~55+ across 8 files)
  </verify>
  <done>All new data layer code has unit tests. queries-users.test.ts validates LIST_USERS query shape. queries-content.test.ts updated with sort parameter tests. stores-userSelection.test.ts validates session persistence and initialization. All tests pass.</done>
</task>

</tasks>

<verification>
1. Backend: `cd backend && make test` — all tests pass (78+)
2. Backend: `cd backend && go build ./...` — compiles without errors
3. Frontend: `cd fe && pnpm run check` — type checking passes
4. Frontend: `cd fe && pnpm test:run` — all tests pass (55+)
5. Schema: grep `users:` in schema.graphql confirms query exists
6. Store: grep `sessionStorage` in userSelection.svelte.ts confirms persistence
</verification>

<success_criteria>
- Backend `users: [User!]!` query fully implemented (schema -> repo -> service -> resolver)
- Frontend LIST_USERS query defined in users.ts
- Frontend LIST_CONTENT query updated with sortBy, sortOrder, includeTotalCount params and length/lengthUnits fields
- User selection store persists to/loads from session storage with browser guard
- All existing tests still pass (backend 78+, frontend 42+)
- New unit tests pass for all three frontend data layer files
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-layer-activity/02-01-SUMMARY.md`
</output>
