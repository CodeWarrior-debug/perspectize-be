---
phase: 03.2-activity-page-beta-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - perspectize-go/schema.graphql
  - perspectize-go/internal/adapters/graphql/resolvers/helpers.go
  - perspectize-go/internal/core/domain/pagination.go
  - perspectize-go/internal/adapters/repositories/postgres/content_repository.go
  - perspectize-go/internal/adapters/graphql/generated/generated.go
  - perspectize-go/internal/adapters/graphql/model/models_gen.go
  - perspective-go/internal/adapters/graphql/resolvers/schema.resolvers.go
autonomous: true

must_haves:
  truths:
    - "GraphQL content query returns channelTitle, publishedAt, tags, and description fields extracted from stored YouTube response JSON"
    - "Content list query accepts search filter for text search on name field"
    - "Content list query sorts by VIEW_COUNT, LIKE_COUNT, or PUBLISHED_AT in addition to existing sort fields"
    - "All existing backend tests pass after changes"
  artifacts:
    - path: "perspectize-go/schema.graphql"
      provides: "Content type with channelTitle, publishedAt, tags, description fields; extended ContentSortBy enum; extended ContentFilter with search"
      contains: "channelTitle"
    - path: "perspectize-go/internal/adapters/graphql/resolvers/helpers.go"
      provides: "domainToModel extracts channelTitle, publishedAt, tags, description from response JSON"
      contains: "ChannelTitle"
    - path: "perspectize-go/internal/core/domain/pagination.go"
      provides: "New ContentSortBy constants and ContentFilter search field"
      contains: "ContentSortByViewCount"
    - path: "perspective-go/internal/adapters/repositories/postgres/content_repository.go"
      provides: "Sort by view_count, like_count, published_at; filter by name ILIKE"
      contains: "view_count"
  key_links:
    - from: "perspective-go/schema.graphql"
      to: "perspectize-go/internal/adapters/graphql/model/models_gen.go"
      via: "make graphql-gen code generation"
      pattern: "ChannelTitle.*string"
    - from: "perspectize-go/internal/adapters/graphql/resolvers/helpers.go"
      to: "perspectize-go/internal/adapters/graphql/model/models_gen.go"
      via: "sets new fields on model.Content"
      pattern: "m\\.ChannelTitle"
---

<objective>
Extend the Go backend to expose new YouTube metadata fields through GraphQL and support additional sorting/filtering needed by the Activity table.

Purpose: The Activity table needs 6 new data fields (channelTitle, publishedAt, tags, description, viewCount in list query, likeCount in list query) and server-side sort/filter capabilities that don't exist yet. The raw YouTube API response already contains all this data in the `response` JSONB column -- we just need to extract and expose it through GraphQL.

Output: Updated GraphQL schema, domain model, helpers, and repository that expose channelTitle, publishedAt, tags, description; support sorting by VIEW_COUNT, LIKE_COUNT, PUBLISHED_AT; and support text search filtering on content name.
</objective>

<execution_context>
@/Users/jamesjordan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesjordan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.2-activity-page-beta-quality/03.2-CONTEXT.md
@.planning/phases/03.2-activity-page-beta-quality/03.2-RESEARCH.md
@perspectize-go/CLAUDE.md

Key existing files to reference:
@perspectize-go/schema.graphql
@perspectize-go/internal/adapters/graphql/resolvers/helpers.go
@perspectize-go/internal/core/domain/pagination.go
@perspectize-go/internal/core/domain/content.go
@perspectize-go/internal/adapters/repositories/postgres/content_repository.go
@perspectize-go/internal/adapters/graphql/resolvers/schema.resolvers.go
@perspectize-go/internal/adapters/youtube/client.go
@perspective-go/gqlgen.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend GraphQL schema with new Content fields, sort options, and search filter</name>
  <files>
    perspective-go/schema.graphql
    perspectize-go/internal/core/domain/pagination.go
    perspectize-go/gqlgen.yml
  </files>
  <action>
    **1. Update `schema.graphql` Content type** — Add these fields to the `Content` type:
    ```graphql
    channelTitle: String
    publishedAt: String
    tags: [String!]
    description: String
    ```
    Place them after `commentCount` and before `response`.

    **2. Extend `ContentSortBy` enum** — Add new sort options:
    ```graphql
    enum ContentSortBy {
      CREATED_AT
      UPDATED_AT
      NAME
      VIEW_COUNT
      LIKE_COUNT
      PUBLISHED_AT
    }
    ```

    **3. Extend `ContentFilter` input** — Add text search capability:
    ```graphql
    input ContentFilter {
      contentType: ContentType
      minLengthSeconds: Int
      maxLengthSeconds: Int
      search: String
    }
    ```
    The `search` field will perform case-insensitive partial match on the `name` column.

    **4. Update `pagination.go`** — Add new domain constants and filter field:
    - Add `ContentSortByViewCount ContentSortBy = "VIEW_COUNT"`
    - Add `ContentSortByLikeCount ContentSortBy = "LIKE_COUNT"`
    - Add `ContentSortByPublishedAt ContentSortBy = "PUBLISHED_AT"`
    - Add `Search *string` field to `ContentFilter` struct

    **5. Run `make graphql-gen`** from `perspectize-go/` directory to regenerate the generated code. This updates `models_gen.go` with the new Content fields and `generated.go` with the new enum values.

    **6. Update `gqlgen.yml`** if needed — The new enum values VIEW_COUNT, LIKE_COUNT, PUBLISHED_AT must map to the domain constants. Since ContentSortBy is already bound in gqlgen.yml to the domain type, and the UPPERCASE values match, no gqlgen.yml change should be needed. Verify after code generation.

    **IMPORTANT:** After `make graphql-gen`, the `schema.resolvers.go` Content resolver signature will be updated with the new filter fields. The resolver already correctly passes the filter to the service, so no resolver change is needed for the filter. However, verify the filter mapping section handles the new `search` field.
  </action>
  <verify>
    - `cd perspectize-go && make graphql-gen` completes without errors
    - `grep "ChannelTitle" internal/adapters/graphql/model/models_gen.go` shows the new field
    - `grep "Tags" internal/adapters/graphql/model/models_gen.go` shows tags field as `[]string`
    - `grep "ContentSortByViewCount" internal/core/domain/pagination.go` shows the new constant
    - `grep "Search" internal/core/domain/pagination.go` shows the new filter field
  </verify>
  <done>
    GraphQL schema has channelTitle, publishedAt, tags, description on Content type; ContentSortBy has VIEW_COUNT, LIKE_COUNT, PUBLISHED_AT; ContentFilter has search field; code generation succeeds; domain model updated with matching constants and filter struct field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract new fields in helpers.go and wire sort/filter in repository</name>
  <files>
    perspectize-go/internal/adapters/graphql/resolvers/helpers.go
    perspectize-go/internal/adapters/repositories/postgres/content_repository.go
    perspectize-go/internal/adapters/graphql/resolvers/schema.resolvers.go
  </files>
  <action>
    **1. Update `helpers.go` domainToModel** — In the existing YouTube response JSON parsing block (where viewCount, likeCount, commentCount are already extracted), also extract:
    - `channelTitle` from `resp.Items[0].Snippet.ChannelTitle` (string)
    - `publishedAt` from `resp.Items[0].Snippet.PublishedAt` (string, ISO 8601 format)
    - `tags` from `resp.Items[0].Snippet.Tags` ([]string)
    - `description` from `resp.Items[0].Snippet.Description` (string)

    Update the anonymous struct used for parsing to include:
    ```go
    var resp struct {
      Items []struct {
        Snippet struct {
          ChannelTitle string   `json:"channelTitle"`
          PublishedAt  string   `json:"publishedAt"`
          Tags         []string `json:"tags"`
          Description  string   `json:"description"`
        } `json:"snippet"`
        Statistics struct {
          ViewCount    string `json:"viewCount"`
          LikeCount    string `json:"likeCount"`
          CommentCount string `json:"commentCount"`
        } `json:"statistics"`
      } `json:"items"`
    }
    ```

    Then set the model fields:
    ```go
    snippet := resp.Items[0].Snippet
    if snippet.ChannelTitle != "" {
      m.ChannelTitle = &snippet.ChannelTitle
    }
    if snippet.PublishedAt != "" {
      m.PublishedAt = &snippet.PublishedAt
    }
    if len(snippet.Tags) > 0 {
      m.Tags = snippet.Tags
    }
    if snippet.Description != "" {
      m.Description = &snippet.Description
    }
    ```

    **2. Update `content_repository.go` sortColumnName** — Add mappings for new sort fields. Note: view_count, like_count, published_at are NOT database columns -- they live in the `response` JSONB. For sorting by these, use JSONB extraction expressions:
    ```go
    case domain.ContentSortByViewCount:
      return "CAST(response->'items'->0->'statistics'->>'viewCount' AS BIGINT)"
    case domain.ContentSortByLikeCount:
      return "CAST(response->'items'->0->'statistics'->>'likeCount' AS BIGINT)"
    case domain.ContentSortByPublishedAt:
      return "response->'items'->0->'snippet'->>'publishedAt'"
    ```

    IMPORTANT: The CAST to BIGINT is needed for numeric sorting (otherwise it sorts alphabetically). For publishedAt, the ISO 8601 format sorts correctly as a string.

    IMPORTANT: These JSONB expressions are safe from SQL injection because they are hardcoded column expressions in a switch statement, not user input. However, they may be NULL for rows without a response. Add `NULLS LAST` to the ORDER BY for these sort fields. Update the `List` method's ORDER BY construction to include NULLS LAST when sorting by JSONB-extracted fields.

    **3. Add search filter to `content_repository.go` List method** — In the filter section of the List method, add handling for the Search field:
    ```go
    if params.Filter.Search != nil && *params.Filter.Search != "" {
      conditions = append(conditions, fmt.Sprintf("name ILIKE $%d", argIdx))
      args = append(args, "%"+*params.Filter.Search+"%")
      argIdx++
    }
    ```
    Also add the same to the count query conditions.

    **4. Update `schema.resolvers.go` Content resolver** — In the filter mapping section, add:
    ```go
    if filter.Search != nil {
      params.Filter.Search = filter.Search
    }
    ```

    **5. Verify all tests pass** — Run `cd perspectize-go && make test` to ensure no regressions. The existing tests mock the response JSON, so the new field extraction should be backward-compatible (fields are nil/empty when not present in response).
  </action>
  <verify>
    - `cd perspectize-go && make test` passes all tests
    - Start the backend server and run a GraphQL query to verify new fields:
      ```bash
      curl -s -X POST http://localhost:8080/graphql \
        -H "Content-Type: application/json" \
        -d '{"query":"{ content(first:1) { items { id name channelTitle publishedAt tags description viewCount likeCount } } }"}' | head -200
      ```
      Should return channelTitle, publishedAt, tags, description values (or null if no YouTube data)
    - Test sort by view count:
      ```bash
      curl -s -X POST http://localhost:8080/graphql \
        -H "Content-Type: application/json" \
        -d '{"query":"{ content(first:3, sortBy:VIEW_COUNT, sortOrder:DESC) { items { id name viewCount } } }"}'
      ```
    - Test search filter:
      ```bash
      curl -s -X POST http://localhost:8080/graphql \
        -H "Content-Type: application/json" \
        -d '{"query":"{ content(first:3, filter:{search:\"test\"}) { items { id name } totalCount } }"}'
      ```
  </verify>
  <done>
    domainToModel extracts channelTitle, publishedAt, tags, description from response JSON. Repository sorts by view_count, like_count, published_at using JSONB extraction. Repository filters by name ILIKE for text search. All existing tests pass. GraphQL queries return the new fields and respect the new sort/filter options.
  </done>
</task>

</tasks>

<verification>
- `cd perspectize-go && make test` — all existing tests pass
- GraphQL playground at http://localhost:8080/graphql returns new fields
- Sorting by VIEW_COUNT, LIKE_COUNT, PUBLISHED_AT returns correctly ordered data
- Search filter returns matching results and correct totalCount
- New fields are null-safe (no crash when response JSON lacks expected structure)
</verification>

<success_criteria>
- GraphQL Content type has channelTitle, publishedAt, tags, description fields
- ContentSortBy enum includes VIEW_COUNT, LIKE_COUNT, PUBLISHED_AT
- ContentFilter input includes search field
- All fields extracted from existing response JSONB (no new YouTube API calls)
- All 78+ backend tests pass
- Frontend test coverage gate: `cd perspective-fe && pnpm run test:coverage` exits 0 (not modified, should still pass)
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-activity-page-beta-quality/03.2-01-SUMMARY.md`
</output>
