---
phase: 03.2-activity-page-beta-quality
plan: 03
type: execute
wave: 2
depends_on: ["03.2-01"]
files_modified:
  - fe/src/lib/queries/content.ts
  - perspective-fe/src/lib/components/ActivityTable.svelte
  - perspective-fe/src/lib/utils/formatting.ts
  - perspective-fe/src/routes/+page.svelte
  - perspective-fe/src/app.css
  - perspective-fe/tests/unit/formatting.test.ts
  - perspective-fe/tests/components/ActivityTable.test.ts
autonomous: true

must_haves:
  truths:
    - "Column header clicks trigger server-side sorting via GraphQL API (not client-side)"
    - "Per-column floating filters send search/filter params to backend (no global search bar)"
    - "Pagination loads one page at a time from backend with total count displayed"
    - "Page size selector offers 10/25/50 options"
    - "6 default visible columns: Item (title+thumbnail), Type (YouTube icon), Length, Views, Likes, Date (YouTube publish date)"
    - "5 hidden columns available via column menu: Channel, Date Added, Date Updated, Tags, Description"
    - "Compact rows ~40-48px height with small thumbnails ~32-40px"
    - "Page header (h-16) and AG Grid column headers are sticky, table body scrolls independently"
    - "Empty state shows 'No items yet - add the first one!' in table body area"
    - "Column header tooltips explain data provenance (e.g. 'from YouTube API')"
  artifacts:
    - path: "perspective-fe/src/lib/queries/content.ts"
      provides: "LIST_CONTENT query requesting all new fields (channelTitle, publishedAt, tags, description, viewCount, likeCount) with filter param"
      contains: "channelTitle"
    - path: "perspective-fe/src/lib/components/ActivityTable.svelte"
      provides: "AG Grid with server-side data fetching, 11 column definitions, floating filters, compact rows, sticky headers, empty state overlay"
      min_lines: 100
    - path: "perspective-fe/src/routes/+page.svelte"
      provides: "Activity page with manual pagination controls, no global search bar"
      contains: "ActivityTable"
    - path: "perspective-fe/src/lib/utils/formatting.ts"
      provides: "Formatters for view count, like count, YouTube icon renderer, thumbnail renderer"
      contains: "formatCount"
  key_links:
    - from: "perspective-fe/src/lib/components/ActivityTable.svelte"
      to: "perspective-fe/src/lib/queries/content.ts"
      via: "graphqlClient.request(LIST_CONTENT, variables)"
      pattern: "graphqlClient\\.request"
    - from: "perspective-fe/src/routes/+page.svelte"
      to: "perspective-fe/src/lib/components/ActivityTable.svelte"
      via: "component rendering"
      pattern: "ActivityTable"
---

<objective>
Rewrite the Activity table for server-side data operations with new YouTube columns, compact rows, sticky headers, floating filters, and data provenance infrastructure.

Purpose: Transform the Activity page from a client-side-fetched-all-data table into a server-driven table where each page, sort, and filter goes through the GraphQL API. Add the 6 new YouTube-sourced columns, compact row styling matching Figma, and provenance tooltips.

Output: Completely rewritten ActivityTable component with manual server-side pagination, 11 column definitions (6 visible, 5 hidden), floating filters, compact rows, sticky headers, empty state overlay, and data provenance tooltips on column headers.
</objective>

<execution_context>
@/Users/jamesjordan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesjordan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.2-activity-page-beta-quality/03.2-CONTEXT.md
@.planning/phases/03.2-activity-page-beta-quality/03.2-RESEARCH.md
@.planning/phases/03.2-activity-page-beta-quality/03.2-01-SUMMARY.md
@fe/CLAUDE.md

Key existing files:
@perspective-fe/src/lib/components/ActivityTable.svelte
@perspective-fe/src/lib/queries/content.ts
@perspective-fe/src/routes/+page.svelte
@perspective-fe/src/lib/utils/formatting.ts
@perspective-fe/src/app.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update GraphQL query and formatting utilities for new columns</name>
  <files>
    perspective-fe/src/lib/queries/content.ts
    perspective-fe/src/lib/utils/formatting.ts
    perspective-fe/tests/unit/formatting.test.ts
  </files>
  <action>
    **1. Update LIST_CONTENT query in `content.ts`** — Add the new fields and filter parameter:
    ```typescript
    export const LIST_CONTENT = gql`
      query ListContent(
        $first: Int
        $after: String
        $sortBy: ContentSortBy = UPDATED_AT
        $sortOrder: SortOrder = DESC
        $includeTotalCount: Boolean = true
        $filter: ContentFilter
      ) {
        content(
          first: $first
          after: $after
          sortBy: $sortBy
          sortOrder: $sortOrder
          includeTotalCount: $includeTotalCount
          filter: $filter
        ) {
          items {
            id
            name
            url
            contentType
            length
            lengthUnits
            viewCount
            likeCount
            channelTitle
            publishedAt
            tags
            description
            createdAt
            updatedAt
          }
          pageInfo {
            hasNextPage
            hasPreviousPage
            endCursor
            startCursor
          }
          totalCount
        }
      }
    `;
    ```

    Key changes: Added `filter` variable, added `viewCount`, `likeCount`, `channelTitle`, `publishedAt`, `tags`, `description` to item fields, added `hasPreviousPage` and `startCursor` to pageInfo.

    **2. Add ContentItem TypeScript interface** — Export a TypeScript interface for the content row data:
    ```typescript
    export interface ContentItem {
      id: string;
      name: string;
      url: string | null;
      contentType: string;
      length: number | null;
      lengthUnits: string | null;
      viewCount: number | null;
      likeCount: number | null;
      channelTitle: string | null;
      publishedAt: string | null;
      tags: string[] | null;
      description: string | null;
      createdAt: string;
      updatedAt: string;
    }

    export interface ContentResponse {
      content: {
        items: ContentItem[];
        pageInfo: {
          hasNextPage: boolean;
          hasPreviousPage: boolean;
          endCursor: string | null;
          startCursor: string | null;
        };
        totalCount: number | null;
      };
    }
    ```

    **3. Add formatting utilities** — Add to `formatting.ts`:

    ```typescript
    /**
     * Format large numbers with K/M suffixes.
     * e.g., 1234 -> "1.2K", 1234567 -> "1.2M"
     */
    export function formatCount(count: number | null): string {
      if (count === null || count === undefined) return '--';
      if (count >= 1_000_000) return `${(count / 1_000_000).toFixed(1)}M`;
      if (count >= 1_000) return `${(count / 1_000).toFixed(1)}K`;
      return count.toLocaleString();
    }

    /**
     * Format YouTube publish date (ISO 8601) to short date.
     */
    export function formatPublishDate(isoString: string | null): string {
      if (!isoString) return '--';
      return formatDate(isoString);
    }

    /**
     * Format tags array to comma-separated string.
     */
    export function formatTags(tags: string[] | null): string {
      if (!tags || tags.length === 0) return '--';
      return tags.join(', ');
    }

    /**
     * Truncate description to maxLength with ellipsis.
     */
    export function truncateDescription(desc: string | null, maxLength: number = 80): string {
      if (!desc) return '--';
      if (desc.length <= maxLength) return desc;
      return desc.slice(0, maxLength) + '...';
    }
    ```

    **4. Add AG Grid cell renderer for Item column (title + thumbnail):**
    Update `nameCellRenderer` to show a small thumbnail next to the title. The YouTube thumbnail URL can be derived from the video URL:
    ```typescript
    /**
     * Extract YouTube video ID from a URL for thumbnail generation.
     */
    function extractVideoIdFromUrl(url: string | null): string | null {
      if (!url) return null;
      try {
        const urlObj = new URL(url);
        if (urlObj.hostname === 'youtu.be') return urlObj.pathname.slice(1);
        return urlObj.searchParams.get('v');
      } catch {
        return null;
      }
    }

    /**
     * AG Grid cell renderer for Item column (thumbnail + title).
     */
    export function itemCellRenderer(params: { data?: ContentItem }): HTMLElement | string {
      if (!params.data) return '';

      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.alignItems = 'center';
      container.style.gap = '8px';
      container.style.height = '100%';

      const videoId = extractVideoIdFromUrl(params.data.url);
      if (videoId) {
        const img = document.createElement('img');
        img.src = `https://i.ytimg.com/vi/${videoId}/default.jpg`;
        img.alt = '';
        img.style.width = '40px';
        img.style.height = '30px';
        img.style.objectFit = 'cover';
        img.style.borderRadius = '2px';
        img.style.flexShrink = '0';
        container.appendChild(img);
      }

      const textEl = document.createElement('span');
      textEl.style.overflow = 'hidden';
      textEl.style.textOverflow = 'ellipsis';
      textEl.style.whiteSpace = 'nowrap';
      if (params.data.url) {
        const a = document.createElement('a');
        a.href = params.data.url;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        a.className = 'text-primary hover:underline';
        a.textContent = params.data.name;
        a.title = params.data.name;  // Full title on hover
        textEl.appendChild(a);
      } else {
        textEl.textContent = params.data.name;
        textEl.title = params.data.name;
      }
      container.appendChild(textEl);

      return container;
    }
    ```

    **5. Add YouTube icon cell renderer for Type column:**
    ```typescript
    /**
     * AG Grid cell renderer for Type column (YouTube icon).
     */
    export function typeCellRenderer(params: { data?: ContentItem }): HTMLElement | string {
      if (!params.data) return '';
      if (params.data.contentType === 'YOUTUBE') {
        const span = document.createElement('span');
        span.title = 'YouTube';
        span.textContent = '\u25B6'; // Play triangle as simple icon
        span.style.color = '#FF0000';
        span.style.fontSize = '16px';
        return span;
      }
      return params.data.contentType;
    }
    ```

    Note: Import the `ContentItem` type from content.ts in formatting.ts, or define the interface locally if circular dependency is a concern.

    **6. Add tests for new formatting utilities** — In `formatting.test.ts`, add tests for:
    - `formatCount`: null -> '--', 500 -> '500', 1234 -> '1.2K', 1234567 -> '1.2M'
    - `formatPublishDate`: null -> '--', valid ISO -> formatted date
    - `formatTags`: null -> '--', empty -> '--', ['a', 'b'] -> 'a, b'
    - `truncateDescription`: null -> '--', short -> as-is, long -> truncated with ...
  </action>
  <verify>
    - `cd fe && pnpm run check` passes type checking
    - `cd fe && pnpm run test:run` passes all tests including new formatting tests
    - `grep "channelTitle" perspective-fe/src/lib/queries/content.ts` shows new fields in query
    - `grep "formatCount" perspective-fe/src/lib/utils/formatting.ts` shows new utility
  </verify>
  <done>
    LIST_CONTENT query requests all new YouTube fields. ContentItem interface exported. Formatting utilities for counts, dates, tags, descriptions. Item cell renderer with thumbnail + title. Type cell renderer with YouTube icon. All new utilities tested.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite ActivityTable with server-side pagination, new columns, and page layout</name>
  <files>
    perspective-fe/src/lib/components/ActivityTable.svelte
    perspective-fe/src/routes/+page.svelte
    perspective-fe/src/app.css
    perspective-fe/tests/components/ActivityTable.test.ts
  </files>
  <action>
    **IMPORTANT ARCHITECTURE DECISION:** AG Grid's Server-Side Row Model (SSRM) requires an Enterprise license. This project uses AG Grid Community. Therefore, implement server-side data operations using AG Grid Client-Side Row Model with **manual pagination controls** outside the grid. The pattern:

    1. AG Grid renders ONE page of data at a time (Client-Side Row Model)
    2. Custom pagination controls below the grid (prev/next buttons, page size selector, total count display)
    3. Sorting is handled by catching AG Grid's `onSortChanged` event and re-fetching from the server
    4. Filtering is handled by catching AG Grid's `onFilterChanged` event and re-fetching from the server
    5. Each interaction triggers a new GraphQL query with the appropriate parameters

    This avoids the SSRM license issue AND the cursor-offset pagination mismatch pitfall from the research.

    **1. Rewrite `ActivityTable.svelte`:**

    The component manages its own data fetching. It no longer receives `rowData` as a prop.

    ```svelte
    <script lang="ts">
      import AgGridSvelte5Component from 'ag-grid-svelte5';
      import { ClientSideRowModelModule } from '@ag-grid-community/client-side-row-model';
      import { themeQuartz } from '@ag-grid-community/theming';
      import type { GridApi, GridOptions, SortChangedEvent, FilterChangedEvent, ColDef } from '@ag-grid-community/core';
      import { graphqlClient } from '$lib/queries/client';
      import { LIST_CONTENT, type ContentItem, type ContentResponse } from '$lib/queries/content';
      import {
        formatDuration, formatDate, formatCount, formatPublishDate,
        formatTags, truncateDescription, itemCellRenderer, typeCellRenderer,
        contentRowId
      } from '$lib/utils/formatting';

      // Pagination state
      let pageSize = $state(10);
      let currentPage = $state(0);
      let totalCount = $state<number | null>(null);
      let cursors = $state<(string | null)[]>([null]); // cursor for each page start
      let hasNextPage = $state(false);
      let hasPreviousPage = $state(false);

      // Sort state
      let sortField = $state<string>('UPDATED_AT');
      let sortDirection = $state<string>('DESC');

      // Filter state
      let filterModel = $state<Record<string, any>>({});

      // Data state
      let rowData = $state<ContentItem[]>([]);
      let loading = $state(true);
      let gridApi = $state<GridApi | null>(null);

      const modules = [ClientSideRowModelModule];

      const theme = themeQuartz.withParams({
        fontFamily: "'Geist', system-ui, sans-serif",
        fontSize: 13,
        headerBackgroundColor: '#1a365d',
        headerTextColor: '#ffffff',
        headerFontWeight: 600,
        oddRowBackgroundColor: '#f7fafc',
        rowHoverColor: 'rgba(26, 54, 93, 0.06)',
        borderColor: '#d4d4d4',
        accentColor: '#1a365d',
        foregroundColor: '#171717',
        backgroundColor: '#ffffff',
        selectedRowBackgroundColor: 'rgba(26, 54, 93, 0.08)',
        columnHoverColor: 'rgba(26, 54, 93, 0.04)',
        headerColumnResizeHandleColor: 'rgba(255, 255, 255, 0.5)',
        rowHeight: 44,  // Compact rows
        headerHeight: 40,
      });

      // Column mapping from AG Grid colId to GraphQL ContentSortBy
      const SORT_FIELD_MAP: Record<string, string> = {
        name: 'NAME',
        createdAt: 'CREATED_AT',
        updatedAt: 'UPDATED_AT',
        viewCount: 'VIEW_COUNT',
        likeCount: 'LIKE_COUNT',
        publishedAt: 'PUBLISHED_AT',
      };

      // Default visible columns (6)
      const defaultColumns: ColDef[] = [
        {
          field: 'name',
          headerName: 'Item',
          flex: 2,
          minWidth: 200,
          sortable: true,
          floatingFilter: true,
          filter: 'agTextColumnFilter',
          filterParams: { debounceMs: 500 },
          cellRenderer: itemCellRenderer,
          headerTooltip: 'Video title and thumbnail (from YouTube API — source data)',
        },
        {
          field: 'contentType',
          headerName: 'Type',
          width: 70,
          sortable: false,
          cellRenderer: typeCellRenderer,
          headerTooltip: 'Content type (from YouTube API — source data)',
        },
        {
          field: 'length',
          headerName: 'Length',
          width: 90,
          sortable: false,
          valueGetter: (params) => {
            if (!params.data) return '--';
            return formatDuration(params.data.length, params.data.lengthUnits);
          },
          headerTooltip: 'Video duration (from YouTube API — source data)',
          tooltipValueGetter: () => 'Duration in minutes:seconds',
        },
        {
          field: 'viewCount',
          headerName: 'Views',
          width: 90,
          sortable: true,
          floatingFilter: true,
          filter: 'agNumberColumnFilter',
          filterParams: { debounceMs: 500 },
          valueFormatter: (params) => formatCount(params.value),
          headerTooltip: 'View count (from YouTube API — source data, read-only)',
        },
        {
          field: 'likeCount',
          headerName: 'Likes',
          width: 80,
          sortable: true,
          floatingFilter: true,
          filter: 'agNumberColumnFilter',
          filterParams: { debounceMs: 500 },
          valueFormatter: (params) => formatCount(params.value),
          headerTooltip: 'Like count (from YouTube API — source data, read-only)',
        },
        {
          field: 'publishedAt',
          headerName: 'Date',
          width: 110,
          sortable: true,
          valueFormatter: (params) => formatPublishDate(params.value),
          headerTooltip: 'YouTube publish date (from YouTube API — source data)',
        },
      ];

      // Hidden columns (available via column menu)
      const hiddenColumns: ColDef[] = [
        {
          field: 'channelTitle',
          headerName: 'Channel',
          width: 140,
          sortable: false,
          hide: true,
          headerTooltip: 'YouTube channel name (from YouTube API — source data)',
        },
        {
          field: 'createdAt',
          headerName: 'Date Added',
          width: 110,
          sortable: true,
          hide: true,
          valueFormatter: (params) => formatDate(params.value),
          headerTooltip: 'Date added to Perspectize (database record)',
        },
        {
          field: 'updatedAt',
          headerName: 'Date Updated',
          width: 110,
          sortable: true,
          sort: 'desc',
          hide: true,
          valueFormatter: (params) => formatDate(params.value),
          headerTooltip: 'Last updated in Perspectize (database record)',
        },
        {
          field: 'tags',
          headerName: 'Tags',
          width: 160,
          sortable: false,
          hide: true,
          valueFormatter: (params) => formatTags(params.value),
          headerTooltip: 'YouTube video tags (from YouTube API — source data)',
        },
        {
          field: 'description',
          headerName: 'Description',
          width: 200,
          sortable: false,
          hide: true,
          valueFormatter: (params) => truncateDescription(params.value),
          tooltipValueGetter: (params) => params.data?.description || '',
          headerTooltip: 'Video description (from YouTube API — source data)',
        },
      ];

      const gridOptions: GridOptions<ContentItem> = {
        columnDefs: [...defaultColumns, ...hiddenColumns],
        pagination: false, // We handle pagination manually
        defaultColDef: {
          resizable: true,
          sortable: false,
          menuTabs: ['columnsMenuTab'], // Right-click shows column chooser
        },
        tooltipShowDelay: 300,
        getRowId: contentRowId,
        domLayout: 'normal', // CRITICAL: must be 'normal' for sticky headers
        suppressCellFocus: true,
        overlayNoRowsTemplate: '<span class="text-muted-foreground text-sm">No items yet - add the first one!</span>',
        onGridReady: (params) => {
          gridApi = params.api;
          fetchData();
        },
        onSortChanged: handleSortChanged,
        onFilterChanged: handleFilterChanged,
      };

      function handleSortChanged(event: SortChangedEvent) {
        const sortModel = event.api.getColumnState()
          .filter(col => col.sort)
          .map(col => ({ colId: col.colId, sort: col.sort }));

        if (sortModel.length > 0) {
          const mapped = SORT_FIELD_MAP[sortModel[0].colId!];
          if (mapped) {
            sortField = mapped;
            sortDirection = sortModel[0].sort === 'asc' ? 'ASC' : 'DESC';
          }
        } else {
          sortField = 'UPDATED_AT';
          sortDirection = 'DESC';
        }

        // Reset to first page on sort change
        currentPage = 0;
        cursors = [null];
        fetchData();
      }

      function handleFilterChanged(event: FilterChangedEvent) {
        const model = event.api.getFilterModel();
        filterModel = model || {};

        // Reset to first page on filter change
        currentPage = 0;
        cursors = [null];
        fetchData();
      }

      function buildFilter(): Record<string, any> | undefined {
        const filter: Record<string, any> = {};
        let hasFilter = false;

        // Text search from name column floating filter
        if (filterModel.name?.filter) {
          filter.search = filterModel.name.filter;
          hasFilter = true;
        }

        // Number filters for viewCount and likeCount
        // Note: the backend ContentFilter doesn't support number range filters
        // on viewCount/likeCount yet. For now, only the search filter is wired.
        // viewCount/likeCount floating filters will show but won't filter server-side
        // until the backend is extended. This is acceptable for Phase 3.2.

        return hasFilter ? filter : undefined;
      }

      async function fetchData() {
        loading = true;
        if (gridApi) {
          gridApi.showLoadingOverlay();
        }

        try {
          const variables: Record<string, any> = {
            first: pageSize,
            sortBy: sortField,
            sortOrder: sortDirection,
            includeTotalCount: true,
          };

          // Add cursor for non-first pages
          const cursor = cursors[currentPage];
          if (cursor) {
            variables.after = cursor;
          }

          // Add filter
          const filter = buildFilter();
          if (filter) {
            variables.filter = filter;
          }

          const data = await graphqlClient.request<ContentResponse>(LIST_CONTENT, variables);
          rowData = data.content.items;
          totalCount = data.content.totalCount;
          hasNextPage = data.content.pageInfo.hasNextPage;
          hasPreviousPage = currentPage > 0;

          // Store cursor for next page
          if (data.content.pageInfo.endCursor && hasNextPage) {
            cursors[currentPage + 1] = data.content.pageInfo.endCursor;
          }

          if (gridApi) {
            if (rowData.length === 0) {
              gridApi.showNoRowsOverlay();
            } else {
              gridApi.hideOverlay();
            }
          }
        } catch (err) {
          console.error('Failed to fetch content:', err);
          rowData = [];
          if (gridApi) {
            gridApi.showNoRowsOverlay();
          }
        } finally {
          loading = false;
        }
      }

      function goToNextPage() {
        if (!hasNextPage) return;
        currentPage += 1;
        fetchData();
      }

      function goToPreviousPage() {
        if (currentPage === 0) return;
        currentPage -= 1;
        fetchData();
      }

      function changePageSize(newSize: number) {
        pageSize = newSize;
        currentPage = 0;
        cursors = [null];
        fetchData();
      }

      // Derived values
      let totalPages = $derived(totalCount ? Math.ceil(totalCount / pageSize) : 0);
      let startItem = $derived(currentPage * pageSize + 1);
      let endItem = $derived(Math.min((currentPage + 1) * pageSize, totalCount ?? 0));
    </script>

    <div class="flex flex-col" style="height: calc(100vh - 4rem - 4rem);">
      <!-- AG Grid fills available space -->
      <div class="flex-1 min-h-0">
        <AgGridSvelte5Component {gridOptions} {rowData} {theme} {modules} style="width: 100%; height: 100%;" />
      </div>

      <!-- Custom pagination controls -->
      <div class="flex items-center justify-between border-t border-border px-4 py-2 text-sm text-muted-foreground bg-background">
        <div class="flex items-center gap-2">
          <span>Rows per page:</span>
          <select
            class="border border-input rounded px-2 py-1 text-sm bg-background"
            value={pageSize}
            onchange={(e) => changePageSize(Number((e.target as HTMLSelectElement).value))}
          >
            <option value={10}>10</option>
            <option value={25}>25</option>
            <option value={50}>50</option>
          </select>
        </div>

        <div class="flex items-center gap-4">
          {#if totalCount !== null}
            <span>{startItem}-{endItem} of {totalCount.toLocaleString()}</span>
          {/if}
          <div class="flex gap-1">
            <button
              onclick={goToPreviousPage}
              disabled={currentPage === 0}
              class="px-2 py-1 border border-input rounded hover:bg-accent disabled:opacity-40 disabled:cursor-not-allowed"
              aria-label="Previous page"
            >
              &larr;
            </button>
            <button
              onclick={goToNextPage}
              disabled={!hasNextPage}
              class="px-2 py-1 border border-input rounded hover:bg-accent disabled:opacity-40 disabled:cursor-not-allowed"
              aria-label="Next page"
            >
              &rarr;
            </button>
          </div>
        </div>
      </div>
    </div>
    ```

    CRITICAL IMPLEMENTATION NOTES:
    - `domLayout: 'normal'` (NOT 'autoHeight') so AG Grid creates its own scroll container for sticky column headers
    - Grid height set via flex container: `calc(100vh - 4rem - 4rem)` accounts for page header (h-16 = 4rem) and Activity heading area (~4rem)
    - Pagination is manual (buttons + GraphQL cursor pagination), not AG Grid built-in pagination
    - AG Grid sorts trigger re-fetch, not client-side sorting
    - `menuTabs: ['columnsMenuTab']` enables right-click column chooser for showing/hiding columns
    - `rowHeight: 44` and `headerHeight: 40` in theme params for compact rows
    - All column header tooltips follow the provenance pattern: "[field name] (from [source] -- [tier])"

    **2. Simplify `+page.svelte`:**
    The Activity page no longer manages data fetching -- ActivityTable does it internally.

    ```svelte
    <script lang="ts">
      import ActivityTable from '$lib/components/ActivityTable.svelte';
    </script>

    <div class="flex flex-col h-[calc(100vh-4rem)]">
      <!-- Activity heading -->
      <div class="px-4 md:px-6 lg:px-8 py-3 flex items-center justify-between">
        <h1 class="text-2xl font-bold">Activity</h1>
      </div>

      <!-- Table fills remaining space -->
      <div class="flex-1 min-h-0 px-4 md:px-6 lg:px-8 pb-2">
        <ActivityTable />
      </div>
    </div>
    ```

    Key changes from current +page.svelte:
    - REMOVED: PageWrapper (no longer needed -- the page manages its own layout for maximum table real estate)
    - REMOVED: Global search input
    - REMOVED: Subtitle "Recently updated content"
    - REMOVED: Content query and data fetching (moved into ActivityTable)
    - REMOVED: Error/loading states (handled inside ActivityTable)
    - ActivityTable now takes NO props (it manages its own data)
    - Full-height layout: heading + table fills viewport

    **3. Update `app.css`** — Add styles for AG Grid floating filter rows if needed. The floating filters add an extra row below column headers. They should inherit the grid's theme. No additional CSS should be needed since `themeQuartz` handles floating filter styling, but verify the filter inputs look clean with the navy header theme.

    **4. Update `ActivityTable.test.ts`** — The test needs to be updated since ActivityTable no longer accepts `rowData`, `loading`, or `searchText` props. The component now fetches data internally. Update tests to:
    - Mock `graphqlClient.request` to return sample data
    - Test that component renders without errors
    - Test that it creates an AG Grid instance
    - Keep test structure simple since the complex interactions (sort, filter, paginate) require full browser testing

    **5. Run test coverage gate:**
    ```bash
    cd fe && pnpm run test:coverage
    ```
  </action>
  <verify>
    - `cd fe && pnpm run check` passes type checking
    - `cd perspective-fe && pnpm run test:coverage` exits 0 (80% stmts/lines/functions, 75% branches)
    - `cd fe && pnpm run dev` -- Activity page loads with new columns
    - Column headers are sticky (scroll down, headers stay)
    - Clicking a sortable column header re-fetches data from server (check Network tab)
    - Page size selector (10/25/50) re-fetches with correct size
    - Prev/Next buttons navigate between pages via cursor pagination
    - Total count is displayed
    - Floating filter on "Item" column triggers server-side text search
    - Right-click column header shows column chooser
    - Empty database shows "No items yet - add the first one!"
    - Hovering a column header shows provenance tooltip
  </verify>
  <done>
    ActivityTable completely rewritten with: server-side sort (GraphQL sort params sent on column click), server-side pagination (cursor-based, one page at a time, manual controls), per-column floating filters, 6 default visible columns with YouTube data, 5 hidden columns with column chooser, compact 44px rows, sticky headers (domLayout='normal'), empty state overlay, data provenance tooltips on all column headers. Activity page simplified to heading + full-height table.
  </done>
</task>

</tasks>

<verification>
- `cd perspective-fe && pnpm run check` — type checking passes
- `cd perspective-fe && pnpm run test:coverage` — coverage gate passes
- Server-side sorting: column click -> Network tab shows new GraphQL query with sortBy/sortOrder
- Server-side pagination: Next/Prev buttons -> new GraphQL query with after cursor
- Floating filters: type in filter -> debounced GraphQL query with filter param
- 6 columns visible by default, 5 hidden and available via right-click column menu
- Compact rows (~44px), sticky column headers
- Empty state displays "No items yet - add the first one!"
- Column header tooltips show data provenance information
</verification>

<success_criteria>
- Server-side sorting works for all sortable columns (name, views, likes, date, created, updated)
- Server-side pagination fetches one page at a time with total count
- Per-column floating filters (text on name, number on views/likes)
- 6 default columns: Item (thumbnail+title), Type (icon), Length, Views, Likes, Date
- 5 hidden columns: Channel, Date Added, Date Updated, Tags, Description
- Right-click column header shows column chooser
- Compact rows ~44px height
- Sticky page header + sticky AG Grid headers
- Empty state message in table body
- Provenance tooltips on every column header
- Frontend tests pass with 80%+ coverage
</success_criteria>

<output>
After completion, create `.planning/phases/03.2-activity-page-beta-quality/03.2-03-SUMMARY.md`
</output>
