---
phase: 07.1-orm-migration-sqlx-to-gorm
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/go.mod
  - backend/go.sum
  - backend/pkg/database/postgres.go
  - backend/internal/adapters/repositories/postgres/gorm_models.go
  - backend/internal/adapters/repositories/postgres/gorm_mappers.go
  - backend/internal/adapters/repositories/postgres/gorm_user_repository.go
autonomous: true

must_haves:
  truths:
    - "GORM dependency (gorm.io/gorm + gorm.io/driver/postgres) is in go.mod"
    - "ConnectGORM function returns *gorm.DB using the existing pgx driver connection"
    - "GORM models (UserModel, ContentModel, PerspectiveModel) have gorm: tags and zero domain imports"
    - "Bidirectional mappers convert domain <-> GORM models correctly"
    - "GormUserRepository implements repositories.UserRepository interface"
    - "Domain models in core/domain/ have zero GORM imports (hex-clean)"
    - "go build ./... compiles with zero errors"
  artifacts:
    - path: "backend/internal/adapters/repositories/postgres/gorm_models.go"
      provides: "GORM-tagged persistence models for all 3 entities"
      contains: "UserModel, ContentModel, PerspectiveModel"
    - path: "backend/internal/adapters/repositories/postgres/gorm_mappers.go"
      provides: "Bidirectional domain <-> GORM model conversion"
      contains: "userModelToDomain, contentModelToDomain, perspectiveModelToDomain"
    - path: "backend/internal/adapters/repositories/postgres/gorm_user_repository.go"
      provides: "GORM-based user repository implementing port interface"
      contains: "GormUserRepository"
    - path: "backend/pkg/database/postgres.go"
      provides: "ConnectGORM function alongside existing Connect"
  key_links:
    - from: "gorm_user_repository.go"
      to: "ports/repositories/user_repository.go"
      via: "interface implementation"
      pattern: "var _ repositories\\.UserRepository = \\(\\*GormUserRepository\\)"
    - from: "gorm_models.go"
      to: "array_types.go"
      via: "custom array types for PostgreSQL arrays"
      pattern: "StringArray|Int64Array"
---

<objective>
Install GORM dependencies, create GORM persistence models and mappers, add ConnectGORM to the database package, and implement GormUserRepository as the first GORM repository — establishing the complete hex-clean pattern.

Purpose: Establish the GORM foundation and pattern that Plan 02 will replicate for the more complex content and perspective repositories.
Output: Compilable GORM models, mappers, connection helper, and working user repository.
</objective>

<execution_context>
@/Users/jamesjordan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesjordan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/internal/core/domain/user.go
@backend/internal/core/domain/content.go
@backend/internal/core/domain/perspective.go
@backend/internal/core/domain/pagination.go
@backend/internal/core/ports/repositories/user_repository.go
@backend/internal/adapters/repositories/postgres/user_repository.go
@backend/internal/adapters/repositories/postgres/array_types.go
@backend/pkg/database/postgres.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install GORM and create models + mappers</name>
  <files>
    backend/go.mod
    backend/go.sum
    backend/internal/adapters/repositories/postgres/gorm_models.go
    backend/internal/adapters/repositories/postgres/gorm_mappers.go
  </files>
  <action>
    1. Install GORM dependencies:
       ```bash
       cd backend && go get gorm.io/gorm gorm.io/driver/postgres
       ```

    2. Create `gorm_models.go` with GORM-tagged persistence models for all 3 entities:
       - `UserModel` — maps to `users` table. Fields: ID (primaryKey;autoIncrement), Username (not null), Email (uniqueIndex;not null), CreatedAt (autoCreateTime), UpdatedAt (autoUpdateTime). Add `TableName()` returning "users".
       - `ContentModel` — maps to `content` table. Fields: ID, Name (not null), URL (*string, uniqueIndex), ContentType (column:content_type;not null), Length (*int), LengthUnits (*string), Response (json.RawMessage, type:jsonb), CreatedAt, UpdatedAt. Add `TableName()` returning "content".
       - `PerspectiveModel` — maps to `perspectives` table. Fields: ID, Claim (not null;size:255), UserID (not null), ContentID (*int), Like (*string, column:like — reserved word), Quality/Agreement/Importance/Confidence (*int), Privacy (*string), Parts (Int64Array from array_types.go, type:integer[]), Category (*string), Labels (StringArray from array_types.go, type:text[]), Description (*string), ReviewStatus (*string), CategorizedRatings (JSONBArray from perspective_repository.go, type:jsonb[];column:categorized_ratings), CreatedAt, UpdatedAt. Add `TableName()` returning "perspectives".

       IMPORTANT: Use the EXISTING custom types from array_types.go (`StringArray`, `Int64Array`) and `JSONBArray` from perspective_repository.go — do NOT use lib/pq. The prototype .disabled files used pq.Int64Array/pq.StringArray which is WRONG for this migration.

       For CategorizedRatings: reuse the existing `JSONBArray` type already defined in perspective_repository.go (it already implements Scanner/Valuer using StringArray).

    3. Create `gorm_mappers.go` with bidirectional conversion functions:
       - `userModelToDomain(m *UserModel) *domain.User` — direct field copy
       - `userDomainToModel(u *domain.User) *UserModel` — direct field copy (omit timestamps, GORM handles them)
       - `contentModelToDomain(m *ContentModel) *domain.Content` — ContentType needs `strings.ToUpper(m.ContentType)` conversion
       - `contentDomainToModel(c *domain.Content) *ContentModel` — ContentType needs `strings.ToLower(string(c.ContentType))` conversion
       - `perspectiveModelToDomain(m *PerspectiveModel) *domain.Perspective` — Privacy default PUBLIC if nil, ReviewStatus pointer conversion (ToUpper), Parts int64->int, Labels direct, CategorizedRatings JSON unmarshal from JSONBArray strings
       - `perspectiveDomainToModel(p *domain.Perspective) *PerspectiveModel` — Privacy ToLower, ReviewStatus ToLower pointer, Parts int->int64, CategorizedRatings JSON marshal to JSONBArray strings

       Import path: `github.com/CodeWarrior-debug/perspectize/backend/internal/core/domain` (NOT the old path from .disabled files)
  </action>
  <verify>
    ```bash
    cd backend && go build ./...
    ```
    Must compile with zero errors. GORM models must NOT import domain package. Mappers import domain but NOT gorm.
  </verify>
  <done>
    gorm_models.go exists with 3 GORM-tagged models using custom array types (not lib/pq). gorm_mappers.go exists with 6 mapper functions. Both compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ConnectGORM and implement GormUserRepository</name>
  <files>
    backend/pkg/database/postgres.go
    backend/internal/adapters/repositories/postgres/gorm_user_repository.go
  </files>
  <action>
    1. Add `ConnectGORM` function to `pkg/database/postgres.go`:
       ```go
       func ConnectGORM(dsn string, pool PoolConfig) (*gorm.DB, error) {
           // Open raw sql.DB with pgx driver (reuse existing driver)
           sqlDB, err := sql.Open("pgx", dsn)
           if err != nil {
               return nil, fmt.Errorf("failed to open database: %w", err)
           }

           // Configure pool on the raw connection
           sqlDB.SetMaxOpenConns(pool.MaxOpenConns)
           sqlDB.SetMaxIdleConns(pool.MaxIdleConns)
           sqlDB.SetConnMaxLifetime(pool.ConnMaxLifetime)

           // Wrap with GORM
           gormDB, err := gorm.Open(gormPostgres.New(gormPostgres.Config{
               Conn: sqlDB,
           }), &gorm.Config{})
           if err != nil {
               sqlDB.Close()
               return nil, fmt.Errorf("failed to initialize GORM: %w", err)
           }

           return gormDB, nil
       }
       ```
       Add imports: `"database/sql"`, `gormPostgres "gorm.io/driver/postgres"`, `"gorm.io/gorm"`.
       Keep existing `Connect` function unchanged (sqlx still used until Plan 03 wiring).

       Also add a `PingGORM` function:
       ```go
       func PingGORM(ctx context.Context, db *gorm.DB) error {
           sqlDB, err := db.DB()
           if err != nil {
               return fmt.Errorf("failed to get underlying DB: %w", err)
           }
           ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
           defer cancel()
           if err := sqlDB.PingContext(ctx); err != nil {
               return fmt.Errorf("database ping failed: %w", err)
           }
           return nil
       }
       ```

    2. Create `gorm_user_repository.go` implementing `repositories.UserRepository`:
       ```go
       type GormUserRepository struct {
           db *gorm.DB
       }

       // Compile-time interface check
       var _ repositories.UserRepository = (*GormUserRepository)(nil)

       func NewGormUserRepository(db *gorm.DB) *GormUserRepository {
           return &GormUserRepository{db: db}
       }
       ```

       Implement all 5 methods:
       - `Create` — `db.Create(&model)` then convert back to domain. GORM auto-fills ID, CreatedAt, UpdatedAt.
       - `GetByID` — `db.First(&model, id)`. If `errors.Is(err, gorm.ErrRecordNotFound)`, return `domain.ErrNotFound`.
       - `GetByUsername` — `db.Where("username = ?", username).First(&model)`. Same ErrNotFound handling.
       - `GetByEmail` — `db.Where("email = ?", email).First(&model)`. Same ErrNotFound handling.
       - `ListAll` — `db.Order("username ASC").Find(&models)`. Convert slice to domain.

       All methods take `context.Context` and use `db.WithContext(ctx)` for context propagation.
       Import `repositories "github.com/CodeWarrior-debug/perspectize/backend/internal/core/ports/repositories"`.
  </action>
  <verify>
    ```bash
    cd backend && go build ./... && go vet ./...
    ```
    Must compile. The compile-time interface check (`var _ repositories.UserRepository = (*GormUserRepository)(nil)`) proves the interface is satisfied.
  </verify>
  <done>
    ConnectGORM and PingGORM exist in database/postgres.go. GormUserRepository implements all 5 UserRepository methods. Compile-time interface check passes. `go build ./...` succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && go build ./...` — zero errors
2. `cd backend && go test ./...` — all existing tests pass (no tests changed)
3. `grep -r "gorm.io" backend/internal/core/domain/` — returns nothing (domain is hex-clean)
4. `grep "var _ repositories.UserRepository" backend/internal/adapters/repositories/postgres/gorm_user_repository.go` — compile-time check exists
5. Verify gorm_models.go uses StringArray/Int64Array/JSONBArray (not pq.StringArray/pq.Int64Array)
</verification>

<success_criteria>
- GORM deps in go.mod
- 3 GORM models with proper tags, using custom array types
- 6 bidirectional mappers
- ConnectGORM + PingGORM functions
- GormUserRepository satisfying UserRepository port interface
- All existing tests still pass
- Domain layer has zero GORM imports
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-orm-migration-sqlx-to-gorm/07.1-01-SUMMARY.md`
</output>
