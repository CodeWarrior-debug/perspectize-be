---
phase: 07.1-orm-migration-sqlx-to-gorm
plan: 02
type: execute
wave: 2
depends_on: ["07.1-01"]
files_modified:
  - backend/internal/adapters/repositories/postgres/gorm_content_repository.go
  - backend/internal/adapters/repositories/postgres/gorm_perspective_repository.go
autonomous: true

must_haves:
  truths:
    - "GormContentRepository implements repositories.ContentRepository interface"
    - "GormPerspectiveRepository implements repositories.PerspectiveRepository interface"
    - "Content List() supports dynamic ORDER BY including JSONB path expressions (viewCount, likeCount, publishedAt)"
    - "Content List() supports dynamic WHERE filters via GORM chaining (contentType, minLength, maxLength, search ILIKE)"
    - "Perspective List() supports dynamic WHERE filters (userID, contentID, privacy)"
    - "Cursor pagination works with opaque base64 cursors for both content and perspectives"
    - "NULLS LAST applied for JSONB sort fields"
    - "Total count respects filters but not cursor pagination"
    - "go build ./... compiles with zero errors"
  artifacts:
    - path: "backend/internal/adapters/repositories/postgres/gorm_content_repository.go"
      provides: "GORM-based content repository with pagination, sorting, filtering"
      contains: "GormContentRepository"
    - path: "backend/internal/adapters/repositories/postgres/gorm_perspective_repository.go"
      provides: "GORM-based perspective repository with full CRUD and pagination"
      contains: "GormPerspectiveRepository"
  key_links:
    - from: "gorm_content_repository.go"
      to: "ports/repositories/content_repository.go"
      via: "interface implementation"
      pattern: "var _ repositories\\.ContentRepository = \\(\\*GormContentRepository\\)"
    - from: "gorm_perspective_repository.go"
      to: "ports/repositories/perspective_repository.go"
      via: "interface implementation"
      pattern: "var _ repositories\\.PerspectiveRepository = \\(\\*GormPerspectiveRepository\\)"
---

<objective>
Implement GormContentRepository and GormPerspectiveRepository — the two complex repositories with cursor pagination, dynamic sorting (including JSONB expressions), and dynamic filtering via GORM chaining.

Purpose: Complete the GORM repository layer. These are the high-value migrations (51% and 47% code reduction respectively).
Output: Two GORM repositories that satisfy port interfaces, with all pagination/sort/filter behavior preserved.
</objective>

<execution_context>
@/Users/jamesjordan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesjordan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-orm-migration-sqlx-to-gorm/07.1-01-SUMMARY.md
@backend/internal/core/domain/pagination.go
@backend/internal/core/domain/perspective.go
@backend/internal/core/ports/repositories/content_repository.go
@backend/internal/core/ports/repositories/perspective_repository.go
@backend/internal/adapters/repositories/postgres/content_repository.go
@backend/internal/adapters/repositories/postgres/perspective_repository.go
@backend/internal/adapters/repositories/postgres/gorm_models.go
@backend/internal/adapters/repositories/postgres/gorm_mappers.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GormContentRepository</name>
  <files>backend/internal/adapters/repositories/postgres/gorm_content_repository.go</files>
  <action>
    Create `gorm_content_repository.go` implementing `repositories.ContentRepository`:

    ```go
    type GormContentRepository struct {
        db *gorm.DB
    }

    var _ repositories.ContentRepository = (*GormContentRepository)(nil)

    func NewGormContentRepository(db *gorm.DB) *GormContentRepository {
        return &GormContentRepository{db: db}
    }
    ```

    Implement 4 methods:

    **Create(ctx, content):**
    - Convert domain to model via `contentDomainToModel`
    - `db.WithContext(ctx).Create(&model)`
    - Convert back via `contentModelToDomain`

    **GetByID(ctx, id):**
    - `db.WithContext(ctx).First(&model, id)`
    - Handle `gorm.ErrRecordNotFound` -> `domain.ErrNotFound`
    - Convert via `contentModelToDomain`

    **GetByURL(ctx, url):**
    - `db.WithContext(ctx).Where("url = ?", url).First(&model)`
    - Same ErrNotFound handling

    **List(ctx, params):**
    This is the complex method. Use GORM chaining for dynamic queries:

    1. Start with `query := r.db.WithContext(ctx).Model(&ContentModel{})`

    2. Apply filters via chaining (replaces the boolean flag pattern):
       ```go
       if params.Filter != nil {
           if params.Filter.ContentType != nil {
               query = query.Where("content_type = ?", strings.ToLower(string(*params.Filter.ContentType)))
           }
           if params.Filter.MinLengthSeconds != nil {
               query = query.Where("length >= ?", *params.Filter.MinLengthSeconds)
           }
           if params.Filter.MaxLengthSeconds != nil {
               query = query.Where("length <= ?", *params.Filter.MaxLengthSeconds)
           }
           if params.Filter.Search != nil && *params.Filter.Search != "" {
               query = query.Where("name ILIKE ?", "%"+*params.Filter.Search+"%")
           }
       }
       ```

    3. Total count (before cursor/limit — respects filters only):
       ```go
       if params.IncludeTotalCount {
           var count int64
           if err := query.Count(&count).Error; err != nil {
               return nil, fmt.Errorf("failed to count content: %w", err)
           }
           countInt := int(count)
           result.TotalCount = &countInt
       }
       ```

    4. Cursor pagination:
       - Reuse existing `encodeCursor`/`decodeCursor` functions from content_repository.go (they stay in the package)
       - If `params.After` is set, decode cursor and add `WHERE id < ?` (DESC) or `WHERE id > ?` (ASC)

    5. Dynamic ORDER BY with JSONB support:
       - Reuse existing `sortColumnName()` function — it returns SQL expressions like `(response->'items'->0->'statistics'->>'viewCount')::BIGINT`
       - Reuse `sortDirection()` and `isJSONBSort()` functions
       - Build order clause: `col + " " + dir + nullsClause + ", id " + dir`
       - For JSONB sorts, append " NULLS LAST"
       - Use `query.Order(gorm.Expr(orderClause))`

       IMPORTANT: Use `gorm.Expr()` for the ORDER BY clause because it contains raw SQL expressions (JSONB path extraction). Plain string `.Order()` would also work since GORM passes order strings through, but `gorm.Expr()` makes the intent explicit.

    6. Fetch limit+1 for hasNextPage detection:
       ```go
       query = query.Limit(limit + 1)
       var models []ContentModel
       if err := query.Find(&models).Error; err != nil { ... }
       ```

    7. Build PaginatedContent result (same logic as current sqlx version):
       - hasNext = len(models) > limit, trim to limit
       - hasPrev = params.After != nil
       - Convert models to domain via contentModelToDomain
       - Set StartCursor/EndCursor from first/last item IDs
  </action>
  <verify>
    ```bash
    cd backend && go build ./...
    ```
    Compile-time interface check proves ContentRepository is satisfied.
  </verify>
  <done>
    GormContentRepository implements all 4 ContentRepository methods. Dynamic sorting (including JSONB), filtering (GORM chaining), cursor pagination, and total count all work. Compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GormPerspectiveRepository</name>
  <files>backend/internal/adapters/repositories/postgres/gorm_perspective_repository.go</files>
  <action>
    Create `gorm_perspective_repository.go` implementing `repositories.PerspectiveRepository`:

    ```go
    type GormPerspectiveRepository struct {
        db *gorm.DB
    }

    var _ repositories.PerspectiveRepository = (*GormPerspectiveRepository)(nil)

    func NewGormPerspectiveRepository(db *gorm.DB) *GormPerspectiveRepository {
        return &GormPerspectiveRepository{db: db}
    }
    ```

    Implement 6 methods:

    **Create(ctx, perspective):**
    - Convert via `perspectiveDomainToModel`
    - `db.WithContext(ctx).Create(&model)`
    - After create, fetch fresh record via GetByID (to get DB-generated timestamps), same pattern as current sqlx implementation
    - NOTE: The "like" column is a PostgreSQL reserved word. GORM handles this via the `column:like` tag on the model, so no special quoting needed in queries.

    **GetByID(ctx, id):**
    - `db.WithContext(ctx).First(&model, id)`
    - Handle gorm.ErrRecordNotFound -> domain.ErrNotFound

    **GetByUserAndClaim(ctx, userID, claim):**
    - `db.WithContext(ctx).Where("user_id = ? AND claim = ?", userID, claim).First(&model)`

    **Update(ctx, perspective):**
    - Convert via `perspectiveDomainToModel`
    - Use `db.WithContext(ctx).Save(&model)` — GORM's Save does full update when primary key is set
    - After save, fetch fresh record via GetByID (same as current pattern)

    **Delete(ctx, id):**
    - `result := db.WithContext(ctx).Delete(&PerspectiveModel{}, id)`
    - Check `result.RowsAffected == 0` -> return domain.ErrNotFound
    - Check `result.Error` for DB errors

    **List(ctx, params):**
    Same pattern as content List but with perspective-specific filters:

    1. Start: `query := r.db.WithContext(ctx).Model(&PerspectiveModel{})`

    2. Apply filters:
       ```go
       if params.Filter != nil {
           if params.Filter.UserID != nil {
               query = query.Where("user_id = ?", *params.Filter.UserID)
           }
           if params.Filter.ContentID != nil {
               query = query.Where("content_id = ?", *params.Filter.ContentID)
           }
           if params.Filter.Privacy != nil {
               query = query.Where("privacy = ?", strings.ToLower(string(*params.Filter.Privacy)))
           }
       }
       ```

    3. Total count (before cursor/limit, respects filters)

    4. Cursor pagination: decode After cursor, add id < ? or id > ? condition

    5. ORDER BY: Reuse existing `perspectiveSortColumnName()` function. Perspectives don't have JSONB sorts, so no NULLS LAST needed.
       - Order clause: `col + " " + dir + ", id " + dir`

    6. Fetch limit+1, build PaginatedPerspectives result
  </action>
  <verify>
    ```bash
    cd backend && go build ./... && go test ./...
    ```
    Compile-time check proves PerspectiveRepository is satisfied. All existing tests pass.
  </verify>
  <done>
    GormPerspectiveRepository implements all 6 PerspectiveRepository methods. Full CRUD, dynamic filtering via GORM chaining, cursor pagination. Compiles and all tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && go build ./...` — zero errors
2. `cd backend && go test ./...` — all existing tests pass
3. Compile-time interface checks exist for both repositories
4. No lib/pq imports in any new GORM files
5. Dynamic sort with JSONB expressions works (sortColumnName reused)
6. GORM chaining replaces manual SQL string building for filters
</verification>

<success_criteria>
- GormContentRepository satisfies ContentRepository with pagination, JSONB sort, dynamic filters
- GormPerspectiveRepository satisfies PerspectiveRepository with full CRUD and pagination
- Both use GORM chaining for WHERE clauses (no manual argIdx counting)
- Cursor encoding/decoding reuses existing functions
- Sort column mapping reuses existing functions
- All tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-orm-migration-sqlx-to-gorm/07.1-02-SUMMARY.md`
</output>
