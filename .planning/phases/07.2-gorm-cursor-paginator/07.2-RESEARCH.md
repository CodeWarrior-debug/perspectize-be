# Phase 7.2: gorm-cursor-paginator Integration - Research

**Researched:** 2026-02-13
**Domain:** Cursor-based pagination with GORM, PostgreSQL compound keyset pagination
**Confidence:** HIGH

## Summary

The gorm-cursor-paginator v2 library provides a production-ready solution for cursor-based pagination with GORM, specifically designed to handle compound keyset pagination (the root cause of C-02). The library handles the limit+1 pattern internally, encodes cursors as base64 strings by default, and supports complex SQL expressions including JSONB field extraction via the `SQLRepr` configuration.

Key findings:
- **Library version**: v2.7.0 (latest stable, published May 2025, supports GORM v2)
- **Compound keyset support**: Native support via `Rules` array with multiple keys
- **JSONB expressions**: Supported through `Rule.SQLRepr` field for custom SQL
- **Cursor format**: Base64-encoded by default (compatible with existing frontend contract)
- **Metadata extraction**: Cursor struct returns `After` and `Before` pointers; nil values indicate no more pages

The library will replace 63 lines of hand-rolled pagination code in helpers.go and gorm_content_repository.go with a declarative configuration approach, fixing C-02 by encoding both sort column value AND ID in cursors.

**Primary recommendation:** Use gorm-cursor-paginator v2 with `Rules` configuration for all sort fields, enable `AllowTupleCmp` for PostgreSQL tuple comparison optimization, and map the library's cursor pointers to domain PaginatedContent/PaginatedPerspectives structures.

## Standard Stack

The established libraries/tools for cursor pagination with GORM:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| gorm-cursor-paginator/v2 | v2.7.0 | Cursor-based pagination for GORM v2 | 226 stars, actively maintained (Dec 2024 update), handles compound keyset pagination correctly, supports JSONB expressions |
| GORM | v2.x | ORM layer | Already in use (Phase 7.1 complete) |
| PostgreSQL | 17 | Database | Supports tuple comparison optimization |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| encoding/base64 | stdlib | Cursor encoding | Built into paginator, no custom codec needed |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| gorm-cursor-paginator | Hand-rolled cursor encoding | Hand-rolled is simpler for ID-only cursors but breaks with compound keys (C-02 bug). Library handles edge cases (NULL, tuple comparison, multi-key sorting) |
| v2.7.0 | v1.x | v1 supports GORM v1 only, v2 required for GORM v2 |

**Installation:**
```bash
go get -u github.com/pilagod/gorm-cursor-paginator/v2
```

## Architecture Patterns

### Recommended Project Structure
```
backend/internal/adapters/repositories/postgres/
├── gorm_content_repository.go     # Use paginator in List() method
├── gorm_perspective_repository.go # Use paginator in List() method
├── helpers.go                      # DELETE encodeCursor/decodeCursor, keep sort mapping
└── gorm_models.go                  # No changes needed
```

### Pattern 1: Configure Paginator with Rules
**What:** Use `paginator.New()` with `Rules` for compound keys and custom SQL expressions
**When to use:** Every List() method that supports sorting by non-ID columns
**Example:**
```go
// Source: https://pkg.go.dev/github.com/pilagod/gorm-cursor-paginator/v2/paginator
import (
    paginator "github.com/pilagod/gorm-cursor-paginator/v2/paginator"
)

// For ContentSortByCreatedAt (DESC):
p := paginator.New(
    paginator.WithRules(
        paginator.Rule{Key: "CreatedAt", Order: paginator.DESC},
        paginator.Rule{Key: "ID", Order: paginator.DESC}, // Tie-breaker
    ),
    paginator.WithLimit(limit),
    paginator.WithAfter(params.After), // Pass cursor string directly
    paginator.WithAllowTupleCmp(paginator.TRUE), // PostgreSQL optimization
)

var models []ContentModel
result, cursor, err := p.Paginate(r.db.WithContext(ctx), &models)
if err != nil {
    return nil, fmt.Errorf("pagination failed: %w", err)
}

// Determine hasNext/hasPrev from cursor pointers
hasNext := cursor.After != nil
hasPrev := cursor.Before != nil
```

### Pattern 2: JSONB Expression in SQLRepr
**What:** Use `Rule.SQLRepr` to provide custom SQL for JSONB extraction
**When to use:** When sorting by JSONB fields (ViewCount, LikeCount, PublishedAt)
**Example:**
```go
// For ContentSortByViewCount (ASC):
p := paginator.New(
    paginator.WithRules(
        paginator.Rule{
            Key: "ViewCount", // GORM model field name
            SQLRepr: "(response->'items'->0->'statistics'->>'viewCount')::BIGINT",
            Order: paginator.ASC,
        },
        paginator.Rule{Key: "ID", Order: paginator.ASC},
    ),
    paginator.WithLimit(limit),
    paginator.WithAfter(params.After),
    paginator.WithAllowTupleCmp(paginator.TRUE),
)
```
**Note:** The `Key` field must match the GORM model struct field name, even if `SQLRepr` provides custom SQL. The library validates that the key exists in the model schema.

### Pattern 3: Mapping Cursor to Domain
**What:** Convert library cursor to domain PaginatedContent/PaginatedPerspectives
**When to use:** Every List() method return
**Example:**
```go
// After paginator.Paginate():
items := make([]*domain.Content, len(models))
for i := range models {
    items[i] = contentModelToDomain(&models[i])
}

result := &domain.PaginatedContent{
    Items:      items,
    HasNext:    cursor.After != nil,
    HasPrev:    cursor.Before != nil,
    TotalCount: totalCountInt, // Separate query if params.IncludeTotalCount
}

// Extract start/end cursors from first/last items
if len(items) > 0 {
    // Library returns cursor.After/Before for forward/backward pagination
    // For GraphQL startCursor/endCursor, we need cursors for first/last items
    // Build temporary paginators to encode these cursors:

    // StartCursor: encode first item
    startP := paginator.New(paginator.WithRules(/* same rules */))
    startCursor, _ := startP.GetCursorEncoder()(/* first model */)
    result.StartCursor = &startCursor

    // EndCursor: encode last item
    endP := paginator.New(paginator.WithRules(/* same rules */))
    endCursor, _ := endP.GetCursorEncoder()(/* last model */)
    result.EndCursor = &endCursor
}
```
**Update (2026-02-13):** The GetCursorEncoder() pattern above is hypothetical. The actual API for encoding individual items needs verification. If not available, use cursor.After for endCursor (next page starts after last item) and reconstruct startCursor via a separate encode of first item.

### Pattern 4: Bidirectional Pagination
**What:** Support both forward (After) and backward (Before) pagination
**When to use:** When frontend needs to navigate both directions (not currently required per phase description)
**Example:**
```go
// Forward pagination (After cursor)
p := paginator.New(
    paginator.WithRules(/* ... */),
    paginator.WithAfter(params.After), // Non-nil for subsequent pages
)

// Backward pagination (Before cursor) - future use
p := paginator.New(
    paginator.WithRules(/* ... */),
    paginator.WithBefore(params.Before),
)
```
**Current scope:** Phase 7.2 only requires forward pagination (After). Before support can be added later if needed.

### Anti-Patterns to Avoid
- **Using Keys instead of Rules for complex sorting:** Keys is simpler but doesn't support SQLRepr or per-key ordering. Use Rules for JSONB expressions.
- **Setting limit directly in GORM query:** The paginator manages limit internally (adds +1 for hasNext detection). Don't call `.Limit()` on the query before passing to `Paginate()`.
- **Manually encoding/decoding cursors:** The library handles cursor encoding/decoding. Delete hand-rolled `encodeCursor()`/`decodeCursor()` functions.
- **Passing unfiltered query to paginator:** Apply all filters (content type, search, length) to the GORM query BEFORE calling `Paginate()`. The paginator only adds ORDER BY, WHERE (cursor), and LIMIT.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Cursor encoding/decoding | Custom base64 `cursor:<id>` format | gorm-cursor-paginator's built-in encoder | Library encodes multiple keys (sort column + ID), handles edge cases (NULL, empty results) |
| Compound keyset WHERE clause | Manual `WHERE (col, id) > (?, ?)` construction | `AllowTupleCmp` + Rules | Library generates correct SQL for all sort directions, handles NULL replacement, validates against schema |
| hasNext detection | Fetching limit+1 and checking length | cursor.After != nil check | Library handles limit+1 internally, trims results, sets cursor.After to nil when no more pages |
| NULL handling in sort columns | Manual `NULLS LAST` clauses | `Rule.NULLReplacement` | Library replaces NULLs with comparable value during cursor encoding, avoiding NULL comparison issues |

**Key insight:** Cursor pagination with compound keys requires encoding sort column values AND IDs, handling NULLs, and generating correct WHERE clauses for all sort directions (ASC/DESC) and positions (forward/backward). The gorm-cursor-paginator library solves all these problems with a declarative Rule configuration.

## Common Pitfalls

### Pitfall 1: JSONB Sort Fields Not in GORM Model
**What goes wrong:** Library validates that `Rule.Key` exists as a field in the GORM model struct. If you set `Key: "ViewCount"` but ContentModel doesn't have a `ViewCount` field, validation fails with `ErrInvalidModel`.
**Why it happens:** The library uses reflection to validate keys against the model schema, even when SQLRepr provides custom SQL.
**How to avoid:**
1. Add dummy fields to GORM model for JSONB sort columns:
   ```go
   type ContentModel struct {
       // ... existing fields
       ViewCount  int64 `gorm:"-"` // Not a DB column, validation only
       LikeCount  int64 `gorm:"-"`
       PublishedAt string `gorm:"-"`
   }
   ```
2. OR investigate if SQLRepr-only rules can bypass validation (requires testing)
**Warning signs:** `ErrInvalidModel` error when calling `Paginate()` with JSONB sort rules

### Pitfall 2: Mismatched Sort Directions
**What goes wrong:** If the global `Order` is ASC but a specific `Rule.Order` is DESC, the secondary keys (e.g., ID) inherit the global order unless explicitly set. This can cause incorrect cursor comparisons.
**Why it happens:** Rules without explicit `Order` inherit the global `Config.Order`. If you only set `Order` on the primary sort key, the ID tie-breaker may have the wrong direction.
**How to avoid:**
- Set `Order` on ALL rules explicitly:
  ```go
  paginator.WithRules(
      paginator.Rule{Key: "CreatedAt", Order: paginator.DESC},
      paginator.Rule{Key: "ID", Order: paginator.DESC}, // Explicit
  )
  ```
- OR set global order to match most common case and only override primary key
**Warning signs:** Pagination returns duplicate items or skips items when cursors are used

### Pitfall 3: Applying Filters After Paginate()
**What goes wrong:** If filters (content type, search, length) are applied AFTER calling `Paginate()`, the cursor-based WHERE clauses conflict with filter WHERE clauses, causing incorrect results.
**Why it happens:** `Paginate()` modifies the GORM query by adding ORDER BY and cursor-based WHERE. Subsequent `.Where()` calls combine with AND, potentially breaking cursor logic.
**How to avoid:**
- Build the filtered query FIRST, then pass to `Paginate()`:
  ```go
  query := r.db.WithContext(ctx).Model(&ContentModel{})
  if params.Filter.ContentType != nil {
      query = query.Where("content_type = ?", *params.Filter.ContentType)
  }
  // ... more filters
  result, cursor, err := p.Paginate(query, &models)
  ```
**Warning signs:** Pagination works without filters but breaks when filters are applied

### Pitfall 4: Cursor Format Incompatibility
**What goes wrong:** If the library's cursor format differs from the frontend's expected format (opaque base64 strings), GraphQL resolvers may need transformation.
**Why it happens:** The library uses base64 encoding by default, but the exact format (e.g., `cursor:<id>` vs library's internal format) may differ from hand-rolled implementation.
**How to avoid:**
- Test cursor format early with a simple example
- If format differs, use `CursorCodec` interface to customize encoding (v2.7.0+)
- OR map library cursors to/from old format in repository layer temporarily
**Warning signs:** Frontend receives cursors that fail to parse on subsequent requests

### Pitfall 5: TotalCount Query Conflicts with Pagination
**What goes wrong:** Calling `.Count()` on the query AFTER `Paginate()` includes cursor WHERE clauses, returning incorrect total.
**Why it happens:** `Paginate()` modifies the query in-place, adding cursor-based WHERE. A subsequent `.Count()` counts filtered + cursored results, not total matching items.
**How to avoid:**
- Execute `.Count()` BEFORE `Paginate()`:
  ```go
  query := r.db.WithContext(ctx).Model(&ContentModel{}).Where(/* filters */)
  if params.IncludeTotalCount {
      var count int64
      if err := query.Count(&count).Error; err != nil { /* ... */ }
      totalCountInt = &countInt
  }
  // Now paginate the same base query
  result, cursor, err := p.Paginate(query, &models)
  ```
**Warning signs:** TotalCount changes as user pages through results

## Code Examples

Verified patterns from official sources:

### Basic Pagination Setup (Simple Keys)
```go
// Source: https://github.com/pilagod/gorm-cursor-paginator (README example)
import (
    paginator "github.com/pilagod/gorm-cursor-paginator/v2/paginator"
)

p := paginator.New(&paginator.Config{
    Keys:  []string{"ID"},
    Limit: 10,
    Order: paginator.ASC,
})

var users []User
result, cursor, err := p.Paginate(db, &users)
if err != nil {
    // Handle error
}

// cursor.After contains encoded position of last user (or nil if no more)
// cursor.Before contains encoded position of first user (or nil if first page)
```

### Compound Keys with Descending Order
```go
// Source: https://pkg.go.dev/github.com/pilagod/gorm-cursor-paginator/v2/paginator (Rules documentation)
p := paginator.New(
    paginator.WithRules(
        paginator.Rule{Key: "CreatedAt", Order: paginator.DESC},
        paginator.Rule{Key: "ID", Order: paginator.DESC},
    ),
    paginator.WithLimit(limit),
    paginator.WithAfter(cursorString), // nil for first page
    paginator.WithAllowTupleCmp(paginator.TRUE),
)

var orders []Order
result, cursor, err := p.Paginate(db, &orders)
```

### JSONB Expression with NULL Handling
```go
// Source: Adapted from https://pkg.go.dev/github.com/pilagod/gorm-cursor-paginator/v2/paginator (Rule.NULLReplacement docs)
p := paginator.New(
    paginator.WithRules(
        paginator.Rule{
            Key:             "ViewCount",
            SQLRepr:         "(response->'items'->0->'statistics'->>'viewCount')::BIGINT",
            Order:           paginator.DESC,
            NULLReplacement: int64(0), // Treat NULL as 0 for sorting
        },
        paginator.Rule{Key: "ID", Order: paginator.DESC},
    ),
    paginator.WithLimit(limit),
    paginator.WithAfter(afterCursor),
    paginator.WithAllowTupleCmp(paginator.TRUE),
)
```

### Full Content List Implementation (Proposed)
```go
// Source: Synthesized from library docs and current repository pattern
func (r *GormContentRepository) List(ctx context.Context, params domain.ContentListParams) (*domain.PaginatedContent, error) {
    limit := 10
    if params.First != nil {
        limit = *params.First
    }

    // Build rules based on params.SortBy and params.SortOrder
    rules := buildSortRules(params.SortBy, params.SortOrder)

    // Configure paginator
    opts := []paginator.Option{
        paginator.WithRules(rules...),
        paginator.WithLimit(limit),
        paginator.WithAllowTupleCmp(paginator.TRUE),
    }
    if params.After != nil {
        opts = append(opts, paginator.WithAfter(*params.After))
    }
    p := paginator.New(opts...)

    // Build filtered query
    query := r.db.WithContext(ctx).Model(&ContentModel{})
    if params.Filter != nil {
        // Apply filters...
    }

    // Total count BEFORE pagination
    var totalCountInt *int
    if params.IncludeTotalCount {
        var count int64
        if err := query.Count(&count).Error; err != nil {
            return nil, fmt.Errorf("failed to count content: %w", err)
        }
        countInt := int(count)
        totalCountInt = &countInt
    }

    // Paginate
    var models []ContentModel
    _, cursor, err := p.Paginate(query, &models)
    if err != nil {
        return nil, fmt.Errorf("pagination failed: %w", err)
    }

    // Convert to domain
    items := make([]*domain.Content, len(models))
    for i := range models {
        items[i] = contentModelToDomain(&models[i])
    }

    result := &domain.PaginatedContent{
        Items:      items,
        HasNext:    cursor.After != nil,
        HasPrev:    cursor.Before != nil,
        TotalCount: totalCountInt,
    }

    // Set start/end cursors
    if len(items) > 0 {
        // Use cursor.After for endCursor (encodes last item)
        if cursor.After != nil {
            result.EndCursor = cursor.After
        }
        // StartCursor requires encoding first item - may need separate helper
        // TODO: Investigate if library exposes encoder for individual items
    }

    return result, nil
}

func buildSortRules(sortBy domain.ContentSortBy, order domain.SortOrder) []paginator.Rule {
    pOrder := paginator.ASC
    if order == domain.SortOrderDesc {
        pOrder = paginator.DESC
    }

    var primaryRule paginator.Rule
    switch sortBy {
    case domain.ContentSortByCreatedAt:
        primaryRule = paginator.Rule{Key: "CreatedAt", Order: pOrder}
    case domain.ContentSortByUpdatedAt:
        primaryRule = paginator.Rule{Key: "UpdatedAt", Order: pOrder}
    case domain.ContentSortByName:
        primaryRule = paginator.Rule{Key: "Name", Order: pOrder}
    case domain.ContentSortByViewCount:
        primaryRule = paginator.Rule{
            Key:     "ViewCount",
            SQLRepr: "(response->'items'->0->'statistics'->>'viewCount')::BIGINT",
            Order:   pOrder,
            NULLReplacement: int64(0),
        }
    case domain.ContentSortByLikeCount:
        primaryRule = paginator.Rule{
            Key:     "LikeCount",
            SQLRepr: "(response->'items'->0->'statistics'->>'likeCount')::BIGINT",
            Order:   pOrder,
            NULLReplacement: int64(0),
        }
    case domain.ContentSortByPublishedAt:
        primaryRule = paginator.Rule{
            Key:     "PublishedAt",
            SQLRepr: "response->'items'->0->'snippet'->>'publishedAt'",
            Order:   pOrder,
            NULLReplacement: "",
        }
    default:
        primaryRule = paginator.Rule{Key: "CreatedAt", Order: paginator.DESC}
    }

    return []paginator.Rule{
        primaryRule,
        {Key: "ID", Order: pOrder}, // Tie-breaker with same direction
    }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Hand-rolled cursor encoding (ID only) | gorm-cursor-paginator with compound keys | v2.0.0 (2021) introduced Rules | Fixes C-02 bug: cursors now encode sort column value + ID for correct keyset pagination |
| Manual limit+1 fetch and slice | Library handles internally | Core design | Simplifies code, library sets cursor.After = nil when no more pages |
| Custom tuple WHERE clauses | `AllowTupleCmp` option | v2.6.0 (2024) | PostgreSQL optimization: `(col1, col2) > (?, ?)` instead of disjunctive normal form |
| Hardcoded cursor format | `CursorCodec` interface | v2.7.0 (May 2025) | Allows custom encoding (e.g., JSON instead of reflection-based) |
| No JSONB support | `Rule.SQLRepr` for custom SQL | Early versions | Enables sorting by PostgreSQL JSONB expressions |

**Deprecated/outdated:**
- **v1.x library:** Supports GORM v1 only. Use v2.x for GORM v2 (current project stack).
- **Keys-only configuration:** Still supported but limited. Use Rules for any non-trivial sorting (custom SQL, per-key ordering, NULL handling).

## Open Questions

Things that couldn't be fully resolved:

1. **StartCursor/EndCursor extraction from library**
   - What we know: cursor.After encodes the last item's position (for next page). cursor.Before encodes first item's position (for previous page).
   - What's unclear: The domain requires `StartCursor` (opaque cursor of first item in results) and `EndCursor` (last item). cursor.After/Before are directional (After = next page start, Before = prev page start). It's unclear if the library exposes an encoder to generate cursors for arbitrary items without pagination.
   - Recommendation:
     - Option A: Use cursor.After as EndCursor (semantically correct for "next page starts after this"). Build a separate paginator instance to encode first item for StartCursor.
     - Option B: Check if library exposes `encoder.Encode(model)` method for manual cursor generation (not found in docs but may exist in internal packages).
     - Option C: During implementation, test if cursor.Before can serve as StartCursor for first page (may be nil on initial request).

2. **JSONB Sort Field Validation**
   - What we know: Library validates `Rule.Key` against GORM model schema. SQLRepr provides custom SQL but doesn't bypass key validation.
   - What's unclear: Whether adding `gorm:"-"` dummy fields to ContentModel for ViewCount/LikeCount/PublishedAt will satisfy validation without breaking GORM's auto-migration or queries.
   - Recommendation: Add dummy fields with `gorm:"-"` tag and test. If validation still fails, investigate if library has an option to skip key validation when SQLRepr is provided.

3. **Backward Pagination (Before cursor) Scope**
   - What we know: Library supports bidirectional pagination via `WithBefore()` option. Frontend contract includes `HasPrev` field.
   - What's unclear: Current frontend implementation doesn't send `Before` cursors. Is backward pagination required for Phase 7.2 or can it be deferred?
   - Recommendation: Implement `HasPrev` detection (cursor.Before != nil) but defer full backward pagination support unless frontend requests it. Forward pagination (After) is sufficient to fix C-02.

4. **AllowTupleCmp Compatibility**
   - What we know: `AllowTupleCmp` enables PostgreSQL tuple comparison `(col1, col2) > (?, ?)` for better performance (v2.6.0+).
   - What's unclear: Whether PostgreSQL 17 (current project version) supports tuple comparison for all column types used in sorting (JSONB expressions, timestamps, text).
   - Recommendation: Enable `AllowTupleCmp` and test. If queries fail, fall back to `paginator.FALSE` (library uses disjunctive normal form WHERE clauses instead).

## Sources

### Primary (HIGH confidence)
- [gorm-cursor-paginator v2 GitHub](https://github.com/pilagod/gorm-cursor-paginator) - Official repository, README, examples
- [pkg.go.dev paginator package](https://pkg.go.dev/github.com/pilagod/gorm-cursor-paginator/v2/paginator) - API reference, struct definitions, function signatures
- [pkg.go.dev cursor package](https://pkg.go.dev/github.com/pilagod/gorm-cursor-paginator/v2/cursor) - Cursor struct, encoder/decoder, CustomType interface
- [GitHub Issue #75](https://github.com/pilagod/gorm-cursor-paginator/issues/75) - Explanation of limit+1 pattern and hasMore flag

### Secondary (MEDIUM confidence)
- [go-paginate library](https://github.com/raphaelvigee/go-paginate) - Alternative cursor paginator with explicit hasNext/hasPrev fields (validated common patterns)
- Web search results for pagination patterns (2026) - Cross-reference for cursor-based pagination best practices

### Tertiary (LOW confidence)
- Test file patterns (paginator_paginate_test.go) - Fetched but returned 404, patterns inferred from issue discussions
- CustomType implementation examples - Not found in documentation, interface definition confirmed but no working examples located

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Library version confirmed via pkg.go.dev (v2.7.0, May 2025), installation command verified
- Architecture: HIGH - API signatures confirmed from official docs, patterns synthesized from verified examples
- Pitfalls: MEDIUM - Based on common GORM/pagination issues and library validation behavior (not all tested in practice)
- Code examples: MEDIUM - Basic examples from official docs (HIGH), JSONB examples synthesized from Rule documentation (MEDIUM), full implementation is proposed pattern (needs validation)

**Research date:** 2026-02-13
**Valid until:** 2026-03-13 (30 days - library is stable, v2.7.0 from May 2025, no rapid changes expected)

**Key uncertainties flagged:**
1. StartCursor/EndCursor extraction mechanism (Open Question #1)
2. JSONB field validation workaround (Open Question #2)
3. AllowTupleCmp PostgreSQL 17 compatibility (Open Question #4)

**Verification needed during implementation:**
- Test JSONB Rule configuration with dummy `gorm:"-"` fields
- Confirm cursor format matches frontend expectations (base64 opaque strings)
- Validate tuple comparison works with JSONB expressions on PostgreSQL 17
- Determine if library exposes encoder for manual cursor generation
