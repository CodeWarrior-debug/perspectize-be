---
phase: 07.3-frontend-caching-remediation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/app.html
  - frontend/src/lib/queries/keys.ts
  - frontend/src/lib/queries/users.ts
  - frontend/src/lib/queries/content.ts
autonomous: true

must_haves:
  truths:
    - "Eruda debug script is completely removed from app.html"
    - "CSP meta tag restricts script/connect/img/style/font sources"
    - "Query key factory exports hierarchical keys for content and users"
    - "email field removed from LIST_USERS query"
    - "User and UsersResponse types exported from users.ts"
    - "All graphqlClient.request calls have type parameters"
  artifacts:
    - path: "frontend/src/app.html"
      provides: "Clean HTML shell with CSP meta tag, no eruda"
      contains: "Content-Security-Policy"
    - path: "frontend/src/lib/queries/keys.ts"
      provides: "Query key factory with hierarchical invalidation"
      exports: ["queryKeys"]
    - path: "frontend/src/lib/queries/users.ts"
      provides: "LIST_USERS without email, exports User and UsersResponse types"
      exports: ["LIST_USERS", "User", "UsersResponse"]
    - path: "frontend/src/lib/queries/content.ts"
      provides: "Content queries with type parameters and CreateContentResponse type"
      exports: ["ContentItem", "ContentResponse", "CreateContentResponse"]
  key_links:
    - from: "frontend/src/lib/queries/keys.ts"
      to: "all query consumers"
      via: "import { queryKeys }"
      pattern: "queryKeys\\."
---

<objective>
Security fixes, query key factory, and type safety foundation for TanStack Query migration.

Purpose: Remove P0 security vulnerability (eruda in production), add CSP headers, create the query key factory and type exports that Plans 02 and 03 depend on.
Output: Clean app.html with CSP, query key factory at keys.ts, typed users.ts without PII over-fetching, CreateContentResponse type in content.ts.
</objective>

<execution_context>
@/Users/jamesjordan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesjordan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07.3-frontend-caching-remediation/07.3-RESEARCH.md

@frontend/src/app.html
@frontend/src/lib/queries/content.ts
@frontend/src/lib/queries/users.ts
@frontend/src/lib/queries/client.ts
@frontend/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove eruda and add CSP meta tag to app.html</name>
  <files>frontend/src/app.html</files>
  <action>
    1. Remove the two eruda script tags (lines 10-11: the CDN script and eruda.init()).
    2. Remove the TODO comment on line 9.
    3. Add a CSP meta tag inside the head element, BEFORE the font preload link:

    ```html
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https://i.ytimg.com https://yt3.ggpht.com; connect-src 'self' http://localhost:8080 https://api.perspectize.com; font-src 'self' data:;">
    ```

    IMPORTANT: Use 'unsafe-inline' for both script-src and style-src because Svelte generates inline styles for scoped CSS and transitions. Without it, the UI breaks.

    The connect-src includes both localhost (dev) and the production API URL. The img-src includes YouTube thumbnail CDN domains.

    The eruda script tags are outside the head element (between head and body) -- also verify the body tag moves directly after the closing head tag.
  </action>
  <verify>
    - `grep -c "eruda" frontend/src/app.html` returns 0
    - `grep -c "Content-Security-Policy" frontend/src/app.html` returns 1
    - `cd frontend && pnpm run check` passes (no type errors from HTML changes)
  </verify>
  <done>Eruda completely removed from app.html, CSP meta tag present restricting all source directives.</done>
</task>

<task type="auto">
  <name>Task 2: Create query key factory</name>
  <files>frontend/src/lib/queries/keys.ts</files>
  <action>
    Create NEW file `frontend/src/lib/queries/keys.ts` with hierarchical query key factory.

    Implementation (from RESEARCH.md Pattern 1):

    ```typescript
    /**
     * Centralized query key factory for type-safe, hierarchical cache invalidation.
     *
     * Hierarchy:
     * - ['app'] - Root (invalidates EVERYTHING)
     * - ['app', 'content'] - All content queries
     * - ['app', 'content', 'list'] - All content lists
     * - ['app', 'content', 'list', {filters}] - Specific list with filters
     * - ['app', 'users'] - All user queries
     *
     * Invalidation: queryClient.invalidateQueries({ queryKey: queryKeys.content.lists() })
     */
    export const queryKeys = {
      all: ['app'] as const,

      content: {
        all: () => [...queryKeys.all, 'content'] as const,
        lists: () => [...queryKeys.content.all(), 'list'] as const,
        list: (filters: {
          sortBy?: string;
          sortOrder?: string;
          search?: string;
          first?: number;
          after?: string | null;
        }) => [...queryKeys.content.lists(), filters] as const,
        details: () => [...queryKeys.content.all(), 'detail'] as const,
        detail: (id: string) => [...queryKeys.content.details(), id] as const,
      },

      users: {
        all: () => [...queryKeys.all, 'users'] as const,
        lists: () => [...queryKeys.users.all(), 'list'] as const,
        list: () => [...queryKeys.users.lists()] as const,
        details: () => [...queryKeys.users.all(), 'detail'] as const,
        detail: (id: string) => [...queryKeys.users.details(), id] as const,
      },
    } as const;
    ```

    Key design choices:
    - Top-level `['app']` prefix avoids collision with other potential query systems
    - Each entity has all/lists/list/details/detail hierarchy
    - `as const` enables TypeScript inference of exact array types
    - `list()` accepts filter params so TanStack Query caches each filter combination separately
  </action>
  <verify>
    - File exists at `frontend/src/lib/queries/keys.ts`
    - `cd frontend && pnpm run check` passes (TypeScript compiles the new file)
  </verify>
  <done>Query key factory exists with content and users hierarchies, all functions return readonly tuples.</done>
</task>

<task type="auto">
  <name>Task 3: Fix users.ts PII over-fetching and add types; add CreateContentResponse to content.ts</name>
  <files>
    frontend/src/lib/queries/users.ts
    frontend/src/lib/queries/content.ts
  </files>
  <action>
    **users.ts changes:**
    1. Remove `email` field from LIST_USERS query (it is not displayed in UserSelector)
    2. Export `User` interface (id: string, username: string -- no email)
    3. Export `UsersResponse` interface ({ users: User[] })

    Updated file:
    ```typescript
    import { gql } from 'graphql-request';

    export interface User {
      id: string;
      username: string;
    }

    export interface UsersResponse {
      users: User[];
    }

    export const LIST_USERS = gql`
      query ListUsers {
        users {
          id
          username
        }
      }
    `;
    ```

    **content.ts changes:**
    1. Add `CreateContentResponse` interface for the mutation response type:
    ```typescript
    export interface CreateContentResponse {
      createContentFromYouTube: {
        id: string;
        name: string;
        url: string;
        contentType: string;
        length: number | null;
        lengthUnits: string | null;
        viewCount: number | null;
        likeCount: number | null;
        commentCount: number | null;
        createdAt: string;
      };
    }
    ```
    2. Add this interface AFTER the existing ContentResponse interface (before the LIST_CONTENT query definition).

    ContentItem and ContentResponse already exist and are correct -- leave them unchanged.
  </action>
  <verify>
    - `grep "email" frontend/src/lib/queries/users.ts` returns no results
    - `grep "export interface User" frontend/src/lib/queries/users.ts` returns a match
    - `grep "export interface CreateContentResponse" frontend/src/lib/queries/content.ts` returns a match
    - `cd frontend && pnpm run check` passes
  </verify>
  <done>email removed from LIST_USERS, User/UsersResponse exported from users.ts, CreateContentResponse exported from content.ts. No `any` types in query/mutation type definitions.</done>
</task>

</tasks>

<verification>
1. `grep -c "eruda" frontend/src/app.html` returns 0
2. `grep -c "Content-Security-Policy" frontend/src/app.html` returns 1
3. `ls frontend/src/lib/queries/keys.ts` exists
4. `grep "email" frontend/src/lib/queries/users.ts` returns nothing
5. `cd frontend && pnpm run check` passes with zero errors
6. `cd frontend && pnpm run test:run` -- existing tests still pass (no regressions)
</verification>

<success_criteria>
- Eruda completely removed, CSP meta tag present
- Query key factory created with hierarchical content + users keys
- email removed from LIST_USERS, User/UsersResponse/CreateContentResponse types exported
- All existing tests pass, type checking passes
</success_criteria>

<output>
After completion, create `.planning/phases/07.3-frontend-caching-remediation/07.3-01-SUMMARY.md`
</output>
