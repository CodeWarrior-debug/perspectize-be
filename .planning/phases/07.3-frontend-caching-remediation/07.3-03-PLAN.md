---
phase: 07.3-frontend-caching-remediation
plan: 03
type: execute
wave: 2
depends_on: ["07.3-01"]
files_modified:
  - frontend/src/lib/components/ActivityTable.svelte
autonomous: true

must_haves:
  truths:
    - "ActivityTable uses createQuery with keepPreviousData instead of manual fetchData()"
    - "No manual fetchData() function exists in ActivityTable"
    - "content-added event listener completely removed from ActivityTable"
    - "Query key includes all pagination/sort/filter params for correct caching"
    - "AG Grid callbacks (onSortChanged, onFilterChanged) update reactive state instead of calling fetchData"
    - "Table data refreshes automatically when AddVideo invalidates content queries"
  artifacts:
    - path: "frontend/src/lib/components/ActivityTable.svelte"
      provides: "ActivityTable using TanStack Query declarative data fetching"
  key_links:
    - from: "frontend/src/lib/components/ActivityTable.svelte"
      to: "frontend/src/lib/queries/keys.ts"
      via: "import { queryKeys }"
      pattern: "queryKeys\\.content\\.list"
    - from: "frontend/src/lib/components/ActivityTable.svelte"
      to: "frontend/src/lib/queries/content.ts"
      via: "import { LIST_CONTENT, type ContentResponse }"
      pattern: "graphqlClient\\.request<ContentResponse>"
---

<objective>
Migrate ActivityTable from manual fetchData() to TanStack Query createQuery with declarative pagination.

Purpose: Eliminate the manual data fetching, loading state management, and custom event listening pattern. Replace with TanStack Query's declarative caching model so the table automatically refetches when content queries are invalidated (e.g., after adding a video).
Output: Rewritten ActivityTable.svelte using createQuery with keepPreviousData.
</objective>

<execution_context>
@/Users/jamesjordan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesjordan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07.3-frontend-caching-remediation/07.3-RESEARCH.md
@.planning/phases/07.3-frontend-caching-remediation/07.3-01-SUMMARY.md

@frontend/src/lib/components/ActivityTable.svelte
@frontend/src/lib/queries/keys.ts
@frontend/src/lib/queries/content.ts
@frontend/src/lib/queries/client.ts
@frontend/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace manual fetchData with createQuery</name>
  <files>frontend/src/lib/components/ActivityTable.svelte</files>
  <action>
    Rewrite the data fetching logic in ActivityTable.svelte. Keep ALL existing UI markup (AG Grid, pagination controls, theme, column definitions) unchanged. Only change the data management layer.

    **Add imports:**
    ```typescript
    import { createQuery, keepPreviousData } from '@tanstack/svelte-query';
    import { queryKeys } from '$lib/queries/keys';
    ```

    Keep existing imports: `graphqlClient`, `LIST_CONTENT`, `ContentItem`, `ContentResponse`, AG Grid imports, formatting utils.

    **Replace the data management section (state + fetchData + event listener):**

    Keep these reactive state variables (they drive the query):
    ```typescript
    let gridApi = $state<GridApi | null>(null);
    let pageSize = $state(10);
    let currentPage = $state(0);
    let cursors = $state<(string | null)[]>([null]);
    let sortBy = $state<string>('UPDATED_AT');
    let sortOrder = $state<'ASC' | 'DESC'>('DESC');
    let filterText = $state<string>('');
    let debounceTimer: ReturnType<typeof setTimeout>;
    ```

    REMOVE these state variables (replaced by query):
    - `let rowData = $state<ContentItem[]>([]);` -- replaced by derived from query
    - `let loading = $state(true);` -- replaced by query.isLoading
    - `let totalCount = $state(0);` -- replaced by derived from query

    ADD the TanStack Query:
    ```typescript
    // Derived cursor for current page
    let currentCursor = $derived(cursors[currentPage]);

    // TanStack Query -- declarative data fetching
    const contentQuery = createQuery(() => ({
      queryKey: queryKeys.content.list({
        sortBy,
        sortOrder,
        search: filterText,
        first: pageSize,
        after: currentCursor
      }),
      queryFn: async () => {
        const response = await graphqlClient.request<ContentResponse>(LIST_CONTENT, {
          first: pageSize,
          after: currentCursor,
          sortBy,
          sortOrder,
          filter: filterText ? { search: filterText } : undefined,
          includeTotalCount: true
        });

        // Update cursor stack for next page navigation
        if (response.content.pageInfo.hasNextPage && response.content.pageInfo.endCursor) {
          if (cursors.length === currentPage + 1) {
            cursors = [...cursors, response.content.pageInfo.endCursor];
          }
        }

        return response;
      },
      placeholderData: keepPreviousData,
      staleTime: 60 * 1000, // 1 minute
    }));

    // Derived data from query (reactive)
    const rowData = $derived(contentQuery.data?.content.items ?? []);
    const totalCount = $derived(contentQuery.data?.content.totalCount ?? 0);
    const loading = $derived(contentQuery.isLoading || contentQuery.isPlaceholderData);
    ```

    REMOVE the `fetchData()` function entirely.

    REMOVE the content-added event listener `$effect` (lines 287-298).

    **Update AG Grid callbacks:**

    `onGridReady`: Remove the `fetchData()` call. The query auto-fetches. Keep `gridApi = params.api;`.
    ```typescript
    onGridReady: (params) => {
      gridApi = params.api;
    },
    ```

    `onSortChanged`: Remove the `fetchData()` call at the end. Just update the reactive state variables (sortBy, sortOrder, currentPage, cursors). TanStack Query will automatically refetch because the query key changes.
    ```typescript
    onSortChanged: (event: SortChangedEvent) => {
      const sortModel = event.api.getColumnState()
        .filter(col => col.sort)
        .sort((a, b) => (a.sortIndex ?? 0) - (b.sortIndex ?? 0));

      if (sortModel.length > 0) {
        const col = sortModel[0];
        sortBy = SORT_FIELD_MAP[col.colId ?? 'updatedAt'] ?? 'UPDATED_AT';
        sortOrder = col.sort === 'asc' ? 'ASC' : 'DESC';
      } else {
        sortBy = 'UPDATED_AT';
        sortOrder = 'DESC';
      }

      // Reset to first page (query auto-refetches via key change)
      currentPage = 0;
      cursors = [null];
    },
    ```

    `onFilterChanged`: Same pattern -- remove `fetchData()`, just update state:
    ```typescript
    onFilterChanged: (event: FilterChangedEvent) => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        const filterModel = event.api.getFilterModel();
        const filters = Object.values(filterModel)
          .map((f: any) => f.filter)
          .filter(Boolean)
          .join(' ');
        filterText = filters;

        // Reset to first page (query auto-refetches via key change)
        currentPage = 0;
        cursors = [null];
      }, 500);
    },
    ```

    **Update pagination handlers:**
    Remove `fetchData()` calls from `handleNextPage`, `handlePrevPage`, `handlePageSizeChange`. They just update state; the query key change triggers refetch.

    ```typescript
    function handleNextPage() {
      if (currentPage < Math.ceil(totalCount / pageSize) - 1) {
        currentPage += 1;
      }
    }

    function handlePrevPage() {
      if (currentPage > 0) {
        currentPage -= 1;
      }
    }

    function handlePageSizeChange(newSize: number) {
      pageSize = newSize;
      currentPage = 0;
      cursors = [null];
    }
    ```

    **Keep the loading $effect** that syncs loading state to AG Grid:
    ```typescript
    $effect(() => {
      if (gridApi) {
        gridApi.setGridOption('loading', loading);
      }
    });
    ```
    Note: `loading` is now a `$derived` value, which works the same way in $effect.

    **Keep ALL template markup unchanged** -- the AG Grid component, pagination controls, and page size selector all reference `rowData`, `totalCount`, `loading`, `pageSize`, `currentPage` which are the same variable names (just derived from query now instead of manually managed).

    IMPORTANT: The `rowData` prop passed to `AgGridSvelte5Component` must work with $derived. Since the template uses `{rowData}`, and rowData is now `$derived(...)`, this works transparently in Svelte 5.
  </action>
  <verify>
    - `grep "fetchData" frontend/src/lib/components/ActivityTable.svelte` returns NO matches
    - `grep "content-added" frontend/src/lib/components/ActivityTable.svelte` returns NO matches
    - `grep "createQuery" frontend/src/lib/components/ActivityTable.svelte` returns a match
    - `grep "keepPreviousData" frontend/src/lib/components/ActivityTable.svelte` returns a match
    - `grep "queryKeys" frontend/src/lib/components/ActivityTable.svelte` returns a match
    - `cd frontend && pnpm run check` passes
  </verify>
  <done>ActivityTable uses createQuery with keepPreviousData, no manual fetchData, no custom event listener, query keys encode all params, AG Grid callbacks just update state and let query key changes trigger refetch.</done>
</task>

</tasks>

<verification>
1. `grep -c "fetchData" frontend/src/lib/components/ActivityTable.svelte` returns 0
2. `grep -c "content-added" frontend/src/lib/components/ActivityTable.svelte` returns 0
3. `grep "createQuery" frontend/src/lib/components/ActivityTable.svelte` matches
4. `grep "keepPreviousData" frontend/src/lib/components/ActivityTable.svelte` matches
5. `grep "queryKeys.content.list" frontend/src/lib/components/ActivityTable.svelte` matches
6. `cd frontend && pnpm run check` passes
</verification>

<success_criteria>
- ActivityTable fully migrated to TanStack Query createQuery
- Manual fetchData() eliminated
- content-added event listener removed
- Query key includes sortBy, sortOrder, filterText, pageSize, currentCursor
- placeholderData: keepPreviousData for smooth page transitions
- AG Grid callbacks update reactive state only (no direct fetch calls)
- All existing UI behavior preserved (pagination, sorting, filtering, empty state)
</success_criteria>

<output>
After completion, create `.planning/phases/07.3-frontend-caching-remediation/07.3-03-SUMMARY.md`
</output>
