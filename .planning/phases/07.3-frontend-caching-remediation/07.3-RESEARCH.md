# Phase 7.3: Frontend Caching Remediation - Research

**Researched:** 2026-02-14
**Domain:** TanStack Query caching architecture, SvelteKit CSP, GraphQL type safety
**Confidence:** HIGH

## Summary

This phase addresses seven critical findings from the frontend caching review (2026-02-14), ranging from P0 security issues to architectural anti-patterns. The primary technical challenge is migrating ActivityTable from manual GraphQL fetching to TanStack Query's declarative caching model while eliminating the dual-signal anti-pattern (query invalidation + custom DOM events).

**Key architectural shift:** ActivityTable currently manages state imperatively (manual `fetchData()`, custom window events, stored cursors) and will transition to declarative state management via TanStack Query, which automatically handles caching, invalidation, and loading states. This aligns with established TanStack Query patterns and eliminates fragile coordination between components.

**Primary recommendation:** Use TanStack Query's `createQuery` with `placeholderData: keepPreviousData` for pagination, implement hierarchical query key factory for precise invalidation, add CSP via meta tags (adapter-static prerendering), and extract shared mutation logic into custom hooks following DRY principles.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @tanstack/svelte-query | 6.0.18 | Async state management and caching | Industry standard for server-state management, eliminates manual cache coordination |
| graphql-request | 7.4.0 | Lightweight GraphQL client | Zero-dependency GraphQL client with TypeScript support, pairs well with TanStack Query |
| TanStack Query keepPreviousData | Built-in | Pagination placeholder data | Prevents UI flash during page transitions, official pattern for paginated queries |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @graphql-codegen/cli | Not installed | TypeScript type generation | OPTIONAL - Only if team wants strict GraphQL→TypeScript type generation; current manual types work fine |
| @graphql-codegen/typed-document-node | Not installed | Typed GraphQL documents | OPTIONAL - Pairs with codegen for compile-time query validation |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Manual query keys | @lukemorales/query-key-factory | Third-party library adds dependency; hierarchical pattern is simple enough to hand-roll |
| Meta CSP tags | HTTP headers via _headers file | HTTP headers stronger but require build pipeline changes; meta tags work for prerendered static sites |
| Custom mutation hooks | Inline mutation config | Custom hooks provide better DRY and testability; minimal overhead |

**Installation:**
```bash
# All dependencies already installed in package.json
# No new packages required

# OPTIONAL: If team wants GraphQL codegen
# pnpm add -D @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typed-document-node
```

## Architecture Patterns

### Recommended Project Structure
```
frontend/src/lib/
├── queries/
│   ├── client.ts              # GraphQLClient instance
│   ├── keys.ts                # NEW: Query key factory with hierarchical invalidation
│   ├── content.ts             # Query/mutation definitions + TypedDocumentNode types
│   ├── users.ts               # User queries
│   └── hooks/                 # NEW: Shared mutation hooks
│       └── useAddVideo.ts     # Extracted createMutation hook
├── components/
│   ├── ActivityTable.svelte   # Uses createQuery (not manual fetch)
│   ├── AddVideoPopover.svelte # Uses shared useAddVideo hook
│   └── AddVideoDialog.svelte  # Uses shared useAddVideo hook
```

### Pattern 1: Query Key Factory with Hierarchical Invalidation
**What:** Centralized query key definitions that support prefix-based invalidation
**When to use:** All queries should use factory keys for consistency and type safety

**Example:**
```typescript
// Source: TanStack Query docs + community patterns
// File: src/lib/queries/keys.ts

export const queryKeys = {
  // Top-level keys
  all: ['app'] as const,

  // Content entity
  content: {
    all: () => [...queryKeys.all, 'content'] as const,
    lists: () => [...queryKeys.content.all(), 'list'] as const,
    list: (filters: {
      sortBy?: string;
      sortOrder?: string;
      search?: string;
      first?: number;
      after?: string | null;
    }) => [...queryKeys.content.lists(), filters] as const,
    details: () => [...queryKeys.content.all(), 'detail'] as const,
    detail: (id: string) => [...queryKeys.content.details(), id] as const,
  },

  // Users entity
  users: {
    all: () => [...queryKeys.all, 'users'] as const,
    lists: () => [...queryKeys.users.all(), 'list'] as const,
    list: () => [...queryKeys.users.lists()] as const,
  },
} as const;

// Usage examples:
// - Invalidate ALL content queries: queryClient.invalidateQueries({ queryKey: queryKeys.content.all() })
// - Invalidate ALL content lists: queryClient.invalidateQueries({ queryKey: queryKeys.content.lists() })
// - Invalidate specific list: queryClient.invalidateQueries({ queryKey: queryKeys.content.list({ sortBy: 'UPDATED_AT' }) })
```

**Why hierarchical:** TanStack Query uses prefix matching for invalidation. `['app', 'content']` matches all queries starting with those keys, enabling surgical or broad invalidation as needed.

### Pattern 2: Shared Mutation Hook (DRY)
**What:** Extract mutation logic into reusable custom hooks
**When to use:** When multiple components perform the same mutation (e.g., AddVideoPopover + AddVideoDialog)

**Example:**
```typescript
// Source: TanStack Query reusable patterns
// File: src/lib/queries/hooks/useAddVideo.ts

import { createMutation, useQueryClient } from '@tanstack/svelte-query';
import { toast } from 'svelte-sonner';
import { graphqlClient } from '../client';
import { CREATE_CONTENT_FROM_YOUTUBE } from '../content';
import { queryKeys } from '../keys';

export function useAddVideo() {
  const queryClient = useQueryClient();

  return createMutation(() => ({
    mutationFn: async (url: string) => {
      return graphqlClient.request(CREATE_CONTENT_FROM_YOUTUBE, {
        input: { url }
      });
    },
    onSuccess: (data: any) => {
      const name = data?.createContentFromYouTube?.name ?? 'video';
      toast.success(`Added: ${name}`);
      // Invalidate ALL content lists (will refetch ActivityTable)
      queryClient.invalidateQueries({ queryKey: queryKeys.content.lists() });
    },
    onError: (err: Error) => {
      const message = err.message.toLowerCase();
      if (message.includes('already exists')) {
        toast.error('This video has already been added');
      } else if (message.includes('invalid youtube url') || message.includes('video not found')) {
        toast.error('Invalid YouTube URL or video not found');
      } else {
        toast.error('Failed to add video. Please try again.');
      }
    }
  }));
}
```

**Benefits:**
- Single source of truth for mutation logic
- Consistent error handling across components
- Easy to test in isolation
- Components only handle UI concerns

### Pattern 3: Declarative Pagination with TanStack Query
**What:** Use `createQuery` with `placeholderData: keepPreviousData` for smooth pagination
**When to use:** Any paginated data (replaces manual fetchData + cursor management)

**Example:**
```typescript
// Source: TanStack Query pagination docs
// File: src/lib/components/ActivityTable.svelte

import { createQuery, keepPreviousData } from '@tanstack/svelte-query';
import { graphqlClient } from '$lib/queries/client';
import { LIST_CONTENT } from '$lib/queries/content';
import { queryKeys } from '$lib/queries/keys';

// Reactive state (Svelte 5 runes)
let pageSize = $state(10);
let currentPage = $state(0);
let sortBy = $state('UPDATED_AT');
let sortOrder = $state<'ASC' | 'DESC'>('DESC');
let filterText = $state('');

// Derived cursor from page number (cursors managed internally)
let cursors = $state<(string | null)[]>([null]);
let currentCursor = $derived(cursors[currentPage]);

// TanStack Query - declarative data fetching
const contentQuery = createQuery(() => ({
  queryKey: queryKeys.content.list({
    sortBy,
    sortOrder,
    search: filterText,
    first: pageSize,
    after: currentCursor
  }),
  queryFn: async () => {
    const response = await graphqlClient.request<ContentResponse>(LIST_CONTENT, {
      first: pageSize,
      after: currentCursor,
      sortBy,
      sortOrder,
      filter: filterText ? { search: filterText } : undefined,
      includeTotalCount: true
    });

    // Update cursor stack after fetch
    if (response.content.pageInfo.hasNextPage && response.content.pageInfo.endCursor) {
      if (cursors.length === currentPage + 1) {
        cursors = [...cursors, response.content.pageInfo.endCursor];
      }
    }

    return response;
  },
  placeholderData: keepPreviousData, // Keeps old data visible while new page loads
  staleTime: 60 * 1000 // 1 minute
}));

// Access data reactively
const rowData = $derived(contentQuery.data?.content.items ?? []);
const totalCount = $derived(contentQuery.data?.content.totalCount ?? 0);
const loading = $derived(contentQuery.isLoading || contentQuery.isPlaceholderData);
```

**Key differences from manual approach:**
- ❌ No manual `fetchData()` function
- ❌ No custom `content-added` event listener
- ❌ No manual loading state management
- ✅ Query automatically refetches when dependencies (sortBy, pageSize, etc.) change
- ✅ Automatic error handling via `contentQuery.error`
- ✅ Cache invalidation triggers refetch automatically

### Pattern 4: CSP Meta Tags for Static Sites
**What:** Add Content Security Policy via `<meta http-equiv>` tags in app.html
**When to use:** For adapter-static builds (prerendered static sites)

**Example:**
```html
<!-- Source: SvelteKit CSP patterns for static sites -->
<!-- File: src/app.html -->

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Content Security Policy -->
    <meta http-equiv="Content-Security-Policy" content="
      default-src 'self';
      script-src 'self' 'unsafe-inline';
      style-src 'self' 'unsafe-inline';
      img-src 'self' data: https://i.ytimg.com https://yt3.ggpht.com;
      connect-src 'self' http://localhost:8080 https://api.perspectize.com;
      font-src 'self' data:;
    ">

    <link rel="preload" href="/fonts/Geist-Variable.woff2" as="font" type="font/woff2" crossorigin>
    %sveltekit.head%
  </head>
  <body data-sveltekit-preload-data="hover">
    <div style="display: contents">%sveltekit.body%</div>
  </body>
</html>
```

**Directives explained:**
- `default-src 'self'`: Only load resources from same origin by default
- `script-src 'self' 'unsafe-inline'`: Required for SvelteKit's inline scripts (Svelte uses inline styles for transitions)
- `style-src 'self' 'unsafe-inline'`: Required for Svelte component styles
- `img-src`: Allow images from same origin + YouTube thumbnails
- `connect-src`: Allow GraphQL API connections (dev + prod)
- `font-src`: Allow fonts from same origin + data URIs

**Note:** For adapter-static, meta tags are the ONLY option (no server to set HTTP headers). For production deployments to Netlify/Cloudflare Pages, consider adding `_headers` file for stronger protection.

### Pattern 5: TypeScript Type Parameters for GraphQL Requests
**What:** Explicitly type all `graphqlClient.request<T>()` calls
**When to use:** Every GraphQL request (prevents `any` types)

**Example:**
```typescript
// BAD: Implicit any type
const response = await graphqlClient.request(LIST_CONTENT, variables);
// response is `any` - no type safety

// GOOD: Explicit type parameter
const response = await graphqlClient.request<ContentResponse>(LIST_CONTENT, variables);
// response is ContentResponse - full type safety

// Interface definition
interface ContentResponse {
  content: {
    items: ContentItem[];
    pageInfo: {
      hasNextPage: boolean;
      hasPreviousPage: boolean;
      startCursor: string | null;
      endCursor: string | null;
    };
    totalCount: number;
  };
}
```

**Alternative (advanced):** Use `@graphql-codegen/typed-document-node` to auto-generate types from GraphQL schema. This provides compile-time validation but adds build complexity. Current manual types are sufficient.

### Anti-Patterns to Avoid

- **Manual fetchData() + Custom Events:** Bypasses TanStack Query's cache invalidation system. Use query invalidation only; let queries refetch automatically.
- **Dual Signal Pattern:** Calling both `queryClient.invalidateQueries()` AND `window.dispatchEvent(new CustomEvent('content-added'))` is redundant and error-prone. Invalidation is sufficient.
- **Inline Mutation Duplication:** Repeating mutation logic in multiple components. Extract to shared hooks.
- **Missing Type Parameters:** Calling `graphqlClient.request()` without `<T>` type parameter results in `any` types.
- **Over-fetching PII:** Including fields like `email` in queries when they're not displayed (UserSelector doesn't show email).

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Query cache invalidation | Custom event system (`window.dispatchEvent`) | TanStack Query `queryClient.invalidateQueries()` | Custom events bypass cache, create race conditions, and don't integrate with loading states |
| Pagination loading states | Manual `loading` state + `$effect` | TanStack Query `isLoading`, `isPlaceholderData`, `placeholderData: keepPreviousData` | Built-in states handle all edge cases (refetch, error, stale data), prevent UI flash |
| GraphQL type safety | Manual type assertions | Type parameters on `request<T>()` OR GraphQL Codegen | Type parameters provide instant safety; Codegen adds schema validation |
| Query key management | Inline array literals `['content']` | Centralized query key factory | Factory ensures consistency, enables hierarchical invalidation, provides autocomplete |
| Content Security Policy | Custom middleware | SvelteKit CSP config OR meta tags | SvelteKit handles nonce/hash generation for inline scripts/styles automatically |

**Key insight:** TanStack Query is designed to eliminate imperative cache management. Developers coming from manual fetching often try to "help" the cache with custom events, but this creates more bugs than it solves. Trust the invalidation system.

## Common Pitfalls

### Pitfall 1: Forgetting to Remove Custom Event Listener
**What goes wrong:** After migrating to TanStack Query, the `content-added` event listener in ActivityTable still exists, causing double-refetches
**Why it happens:** Event listener is in a separate `$effect` block, easy to overlook during migration
**How to avoid:** Remove BOTH the event dispatcher (AddVideoPopover line 38) AND listener (ActivityTable lines 287-298) in same commit
**Warning signs:**
- Network tab shows duplicate GraphQL requests after adding video
- Tests fail because mock request is called twice
- Console logs "fetching content" twice

### Pitfall 2: Query Key Doesn't Include Pagination Params
**What goes wrong:** Changing page size or sort order doesn't refetch data; users see stale results
**Why it happens:** Query key `['content']` is too broad; TanStack Query caches by entire key, so `['content']` for page 1 vs page 2 looks the same
**How to avoid:** Include ALL query parameters in key: `queryKeys.content.list({ sortBy, sortOrder, search: filterText, first: pageSize, after: currentCursor })`
**Warning signs:**
- Changing sort order doesn't update table
- Navigation to page 2 shows page 1 data
- Browser DevTools → TanStack Query shows single cached entry for all variations

### Pitfall 3: placeholderData vs keepPreviousData in v5+
**What goes wrong:** Using `keepPreviousData: true` (v4 syntax) instead of `placeholderData: keepPreviousData` (v5+ syntax)
**Why it happens:** TanStack Query v5 deprecated `keepPreviousData` option; migration required
**How to avoid:** Import `keepPreviousData` function from `@tanstack/svelte-query`, use as `placeholderData: keepPreviousData`
**Warning signs:**
- TypeScript error: "Object literal may only specify known properties"
- UI flashes blank during pagination instead of showing previous data
- Vitest shows deprecation warnings

### Pitfall 4: Invalidation Too Broad or Too Narrow
**What goes wrong:**
- Too broad: Invalidating `queryKeys.all` refetches users AND content when only content changed
- Too narrow: Invalidating `queryKeys.content.list({ sortBy: 'UPDATED_AT', ... })` doesn't invalidate lists with different sort orders
**Why it happens:** Misunderstanding TanStack Query's prefix matching
**How to avoid:** Use hierarchical keys; invalidate at the appropriate level:
- Added content → invalidate `queryKeys.content.lists()` (all list variations)
- Updated single content item → invalidate `queryKeys.content.detail(id)` + `queryKeys.content.lists()` (detail + lists)
**Warning signs:**
- Table doesn't update after mutation
- Unnecessary network requests after unrelated mutations

### Pitfall 5: CSP Blocks Inline Styles from Svelte
**What goes wrong:** Adding strict CSP without `'unsafe-inline'` breaks Svelte transitions and component styles
**Why it happens:** Svelte generates inline `<style>` tags for scoped styles and inline style attributes for transitions
**How to avoid:** For adapter-static, must include `style-src 'self' 'unsafe-inline'` in CSP
**Warning signs:**
- Component styles missing in production
- Svelte transitions don't work
- Browser console: "Refused to apply inline style because it violates CSP directive"

**Alternative (advanced):** Use `kit.csp` in `svelte.config.js` to auto-generate hashes for inline styles. Requires dynamic rendering (not compatible with adapter-static prerendering).

### Pitfall 6: Eruda Console Visible in Production
**What goes wrong:** Mobile debug console (eruda) loads from CDN in production, exposing internal app state to users and creating CVSS 7.5 security issue
**Why it happens:** Eruda script tags added to `app.html` during development, never removed
**How to avoid:** Completely remove eruda script tags from `app.html` before deploying. For development, use browser DevTools or conditional loading via environment variable
**Warning signs:**
- Users report "floating bug icon" on mobile
- Security scan flags external script loading
- Console logs visible to end users

## Code Examples

Verified patterns from official sources:

### Example 1: Migrating ActivityTable from Manual Fetch to createQuery

**Before (manual fetch with custom events):**
```typescript
// Manual state management
let loading = $state(true);
let rowData = $state<ContentItem[]>([]);

async function fetchData() {
  loading = true;
  try {
    const response = await graphqlClient.request(LIST_CONTENT, {/*...*/});
    rowData = response.content.items;
  } catch (error) {
    console.error('Error fetching content:', error);
    rowData = [];
  } finally {
    loading = false;
  }
}

// Custom event listener
$effect(() => {
  const handleContentAdded = () => {
    currentPage = 0;
    cursors = [null];
    fetchData();
  };
  window.addEventListener('content-added', handleContentAdded);
  return () => window.removeEventListener('content-added', handleContentAdded);
});
```

**After (TanStack Query declarative):**
```typescript
// Source: TanStack Query Svelte docs
import { createQuery, keepPreviousData } from '@tanstack/svelte-query';
import { queryKeys } from '$lib/queries/keys';

// Reactive dependencies
let pageSize = $state(10);
let currentPage = $state(0);
let sortBy = $state('UPDATED_AT');
let sortOrder = $state<'ASC' | 'DESC'>('DESC');
let filterText = $state('');
let cursors = $state<(string | null)[]>([null]);

// Query automatically refetches when dependencies change
const contentQuery = createQuery(() => ({
  queryKey: queryKeys.content.list({
    sortBy,
    sortOrder,
    search: filterText,
    first: pageSize,
    after: cursors[currentPage]
  }),
  queryFn: async () => {
    const response = await graphqlClient.request<ContentResponse>(LIST_CONTENT, {
      first: pageSize,
      after: cursors[currentPage],
      sortBy,
      sortOrder,
      filter: filterText ? { search: filterText } : undefined,
      includeTotalCount: true
    });

    // Update cursor stack for next page
    if (response.content.pageInfo.hasNextPage && response.content.pageInfo.endCursor) {
      if (cursors.length === currentPage + 1) {
        cursors = [...cursors, response.content.pageInfo.endCursor];
      }
    }

    return response;
  },
  placeholderData: keepPreviousData // Smooth page transitions
}));

// Derived data (reactive)
const rowData = $derived(contentQuery.data?.content.items ?? []);
const totalCount = $derived(contentQuery.data?.content.totalCount ?? 0);
const loading = $derived(contentQuery.isLoading || contentQuery.isPlaceholderData);

// No custom event listener needed!
// When AddVideoPopover invalidates queryKeys.content.lists(),
// this query automatically refetches because its key matches the prefix
```

### Example 2: Shared Mutation Hook Usage

**Component (AddVideoPopover.svelte):**
```typescript
// Source: TanStack Query reusable hooks pattern
import { useAddVideo } from '$lib/queries/hooks/useAddVideo';

let open = $state(false);
let url = $state('');
let error = $state('');

// Use shared mutation hook
const mutation = useAddVideo();

function handleSubmit(e: Event) {
  e.preventDefault();
  if (!validateYouTubeUrl(url)) {
    error = 'Please enter a valid YouTube URL';
    return;
  }
  error = '';
  mutation.mutate(url);
  open = false; // Close popover on success (handled in hook)
}
```

**Hook (useAddVideo.ts):**
```typescript
// Source: TanStack Query mutation patterns
import { createMutation, useQueryClient } from '@tanstack/svelte-query';
import { toast } from 'svelte-sonner';
import { graphqlClient } from '../client';
import { CREATE_CONTENT_FROM_YOUTUBE } from '../content';
import { queryKeys } from '../keys';

export function useAddVideo() {
  const queryClient = useQueryClient();

  return createMutation(() => ({
    mutationFn: async (url: string) => {
      return graphqlClient.request<CreateContentResponse>(CREATE_CONTENT_FROM_YOUTUBE, {
        input: { url }
      });
    },
    onSuccess: (data) => {
      const name = data?.createContentFromYouTube?.name ?? 'video';
      toast.success(`Added: ${name}`);
      // Invalidate all content lists (triggers ActivityTable refetch)
      queryClient.invalidateQueries({ queryKey: queryKeys.content.lists() });
    },
    onError: (err: Error) => {
      const message = err.message.toLowerCase();
      if (message.includes('already exists')) {
        toast.error('This video has already been added');
      } else if (message.includes('invalid youtube url') || message.includes('video not found')) {
        toast.error('Invalid YouTube URL or video not found');
      } else {
        toast.error('Failed to add video. Please try again.');
      }
    }
  }));
}
```

**Benefits:**
- ✅ Single source of truth for error handling
- ✅ Both AddVideoPopover and AddVideoDialog use same hook
- ✅ Easy to test mutation logic in isolation
- ✅ Consistent toast messages across components

### Example 3: Query Key Factory Implementation

```typescript
// Source: TanStack Query community patterns + hierarchical key design
// File: src/lib/queries/keys.ts

/**
 * Centralized query key factory for type-safe, hierarchical cache invalidation.
 *
 * Hierarchy:
 * - ['app'] - Root (invalidates EVERYTHING)
 * - ['app', 'content'] - All content queries
 * - ['app', 'content', 'list'] - All content lists
 * - ['app', 'content', 'list', {filters}] - Specific list with filters
 * - ['app', 'content', 'detail'] - All content details
 * - ['app', 'content', 'detail', id] - Specific content item
 *
 * Usage:
 * - queryKey: queryKeys.content.list({ sortBy: 'UPDATED_AT' })
 * - invalidateQueries({ queryKey: queryKeys.content.lists() }) // Invalidates ALL lists
 * - invalidateQueries({ queryKey: queryKeys.content.all() }) // Invalidates lists AND details
 */

export const queryKeys = {
  // Root key
  all: ['app'] as const,

  // Content entity
  content: {
    all: () => [...queryKeys.all, 'content'] as const,
    lists: () => [...queryKeys.content.all(), 'list'] as const,
    list: (filters: {
      sortBy?: string;
      sortOrder?: string;
      search?: string;
      first?: number;
      after?: string | null;
    }) => [...queryKeys.content.lists(), filters] as const,
    details: () => [...queryKeys.content.all(), 'detail'] as const,
    detail: (id: string) => [...queryKeys.content.details(), id] as const,
  },

  // Users entity
  users: {
    all: () => [...queryKeys.all, 'users'] as const,
    lists: () => [...queryKeys.users.all(), 'list'] as const,
    list: () => [...queryKeys.users.lists()] as const,
    details: () => [...queryKeys.users.all(), 'detail'] as const,
    detail: (id: string) => [...queryKeys.users.details(), id] as const,
  },
} as const;

// TypeScript inference examples:
// queryKeys.content.list({ sortBy: 'UPDATED_AT' })
// → readonly ["app", "content", "list", { sortBy: "UPDATED_AT" }]
//
// queryKeys.content.lists()
// → readonly ["app", "content", "list"]
//
// Invalidation patterns:
// - Added content: invalidate queryKeys.content.lists()
// - Updated content: invalidate queryKeys.content.detail(id) + queryKeys.content.lists()
// - Deleted content: invalidate queryKeys.content.all()
```

### Example 4: CSP Configuration for Static Sites

**Option 1: Meta Tag (adapter-static, RECOMMENDED):**
```html
<!-- File: src/app.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Content Security Policy -->
    <meta http-equiv="Content-Security-Policy" content="
      default-src 'self';
      script-src 'self' 'unsafe-inline';
      style-src 'self' 'unsafe-inline';
      img-src 'self' data: https://i.ytimg.com https://yt3.ggpht.com;
      connect-src 'self' http://localhost:8080 https://api.perspectize.com;
      font-src 'self' data:;
    ">

    <link rel="preload" href="/fonts/Geist-Variable.woff2" as="font" type="font/woff2" crossorigin>
    %sveltekit.head%
  </head>
  <body data-sveltekit-preload-data="hover">
    <div style="display: contents">%sveltekit.body%</div>
  </body>
</html>
```

**Option 2: SvelteKit Config (requires server-side rendering):**
```javascript
// File: svelte.config.js
// NOTE: This does NOT work with adapter-static prerendering
// Only use if migrating to adapter-node or adapter-vercel

import adapter from '@sveltejs/adapter-auto';

/** @type {import('@sveltejs/kit').Config} */
const config = {
  kit: {
    adapter: adapter(),
    csp: {
      mode: 'auto', // 'auto' | 'hash' | 'nonce'
      directives: {
        'default-src': ['self'],
        'script-src': ['self', 'unsafe-inline'],
        'style-src': ['self', 'unsafe-inline'],
        'img-src': ['self', 'data:', 'https://i.ytimg.com', 'https://yt3.ggpht.com'],
        'connect-src': ['self', 'http://localhost:8080', 'https://api.perspectize.com'],
        'font-src': ['self', 'data:'],
      }
    }
  }
};

export default config;
```

**For this phase:** Use Option 1 (meta tags) because project uses adapter-static.

### Example 5: Removing PII Over-Fetching

**Before (includes unused email field):**
```typescript
// File: src/lib/queries/users.ts
export const LIST_USERS = gql`
  query ListUsers {
    users {
      id
      username
      email  # ← NOT USED in UserSelector, PII over-fetching
    }
  }
`;
```

**After (minimal fields only):**
```typescript
// File: src/lib/queries/users.ts
export const LIST_USERS = gql`
  query ListUsers {
    users {
      id
      username
      # email field removed - not displayed in UserSelector
    }
  }
`;

// Update interface to match
export interface User {
  id: string;
  username: string;
  // email: string; ← Remove from type
}
```

**Component adjustment:**
```typescript
// File: src/lib/components/UserSelector.svelte
// Remove inline User interface, import from users.ts
import { LIST_USERS, type User } from '$lib/queries/users';

// OLD: interface User { id: string; username: string; email: string; }
// NEW: Import shared type
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `keepPreviousData: true` | `placeholderData: keepPreviousData` | TanStack Query v5 (2023) | Import keepPreviousData function instead of boolean option |
| Manual query keys `['content']` | Query key factories | Community pattern (2024+) | Hierarchical invalidation, type safety, autocomplete |
| CSP via server headers only | Meta tags for static sites | SvelteKit adapter-static pattern | Enables CSP in prerendered static builds |
| GraphQL Codegen required | Manual types OR codegen | graphql-request v5+ (2023) | Type parameters provide "good enough" safety without build step |
| Custom event systems | TanStack Query invalidation | TanStack Query v3+ (2021) | Declarative cache management eliminates event coordination |

**Deprecated/outdated:**
- **`keepPreviousData: true`** (v4 syntax): Use `placeholderData: keepPreviousData` (v5+)
- **`isPreviousData` flag**: Use `isPlaceholderData` (v5+)
- **Eruda in production**: Always was bad practice; remove from production builds
- **`kit.csp` with adapter-static**: Config ignored by static adapter; use meta tags

## Open Questions

Things that couldn't be fully resolved:

1. **Should we add GraphQL Codegen?**
   - What we know: Codegen provides schema→TypeScript type generation and compile-time validation
   - What's unclear: Is manual type maintenance (current approach) painful enough to justify codegen build step?
   - Recommendation: Start with manual types + type parameters. Add codegen if team reports type drift issues after 2-3 months

2. **Should CSP be stricter (remove unsafe-inline)?**
   - What we know: `'unsafe-inline'` required for Svelte transitions and scoped styles with adapter-static
   - What's unclear: Is security risk worth breaking Svelte features?
   - Recommendation: Keep `'unsafe-inline'` for adapter-static. If migrating to adapter-node/vercel, use SvelteKit `kit.csp` with mode: 'hash' to auto-generate hashes for inline styles

3. **Should we migrate adapter-static → adapter-node for better CSP?**
   - What we know: adapter-node enables server-side CSP headers with frame-ancestors, report-uri, hash mode
   - What's unclear: Is static site generation (SSG) a hard requirement? Does team want server infrastructure?
   - Recommendation: Keep adapter-static for now (simpler deployment). Revisit if CSP requirements become stricter

4. **Eruda replacement for mobile debugging?**
   - What we know: Eruda must be removed from production
   - What's unclear: Does team still need mobile debugging? What's the replacement workflow?
   - Recommendation: Remove eruda completely. Use browser DevTools remote debugging (Chrome → chrome://inspect, Safari → Develop menu). Add Sentry or similar for production error tracking if needed

## Sources

### Primary (HIGH confidence)
- [TanStack Query Query Invalidation](https://tanstack.com/query/v5/docs/react/guides/query-invalidation) - Hierarchical key matching, prefix invalidation
- [TanStack Query Paginated Queries](https://tanstack.com/query/v4/docs/react/guides/paginated-queries) - keepPreviousData pattern
- [TanStack Query Migration to v5](https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5) - placeholderData migration
- [SvelteKit Configuration](https://svelte.dev/docs/kit/configuration) - CSP config options
- [TanStack Query Svelte Overview](https://tanstack.com/query/v5/docs/framework/svelte/overview) - Svelte 5 function wrapper pattern
- [GraphQL Codegen TypedDocumentNode](https://the-guild.dev/graphql/codegen/plugins/typescript/typed-document-node) - Type generation patterns

### Secondary (MEDIUM confidence)
- [Rodney Lab SvelteKit CSP](https://rodneylab.com/sveltekit-content-security-policy/) - Meta tag implementation for static sites
- [Hugo Sum CSP in SvelteKit](https://hugosum.com/blog/creating-content-security-policy-in-sveltekit) - Prerender CSP patterns
- [TanStack Query Reusable Patterns](https://spin.atomicobject.com/tanstack-query-reusable-patterns/) - Custom mutation hooks
- [Building Reusable Queries with TanStack Query](https://oluwadaprof.medium.com/building-reusable-queries-with-tanstack-query-a618c5bc82ff) - Query key factories
- [GraphQL Security Guide](https://www.stackhawk.com/blog/graphql-security/) - PII over-fetching risks
- [OWASP GraphQL Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html) - Security best practices

### Tertiary (LOW confidence)
- [TanStack Query GitHub Discussions #7263](https://github.com/TanStack/query/discussions/7263) - Community invalidation patterns
- [TanStack Query GitHub Discussions #6460](https://github.com/TanStack/query/discussions/6460) - keepPreviousData deprecation discussion
- [Wisp CMS Query Keys Article](https://www.wisp.blog/blog/managing-query-keys-for-cache-invalidation-in-react-query) - Cache invalidation patterns
- [Efficient Data Fetching with TanStack React Query](https://krishaniindrachapa.medium.com/efficient-data-fetching-with-tanstack-react-query-f88589d80ea0) - General best practices

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already installed, TanStack Query v6 is latest stable, patterns verified in official docs
- Architecture: HIGH - Query key factory, shared hooks, and declarative queries are established patterns with official documentation
- Pitfalls: MEDIUM - Drawn from community discussions and common migration issues; some project-specific (e.g., eruda, cursor management)
- CSP implementation: MEDIUM - Meta tag approach verified for adapter-static, but stricter CSP requires adapter changes

**Research date:** 2026-02-14
**Valid until:** 2026-03-16 (30 days - TanStack Query stable, Svelte 5 stable, SvelteKit patterns mature)

**Key assumptions:**
1. Project stays on adapter-static (SSG) - If migrating to SSR, CSP implementation changes
2. Manual GraphQL types acceptable - If type drift becomes issue, add codegen
3. Current TanStack Query v6 patterns remain stable - Major version changes would require re-research
4. Svelte 5 runes syntax remains standard - No breaking changes expected

**Research limitations:**
- Could not fetch official TanStack Query docs (303 redirects) - relied on cached knowledge + community sources verified against search results
- Eruda security vulnerability search returned no specific CVE - severity based on general principle of debug tools in production
- No direct comparison testing between meta tags vs HTTP headers CSP - implementation choice based on adapter constraints
