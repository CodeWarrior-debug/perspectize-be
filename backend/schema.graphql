scalar JSON
scalar IntID

# User type
type User {
  id: ID!
  username: String!
  email: String!
  active: Boolean!
  createdAt: String!
  updatedAt: String!
}

# Perspective enums
enum Privacy {
  PUBLIC
  PRIVATE
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

enum PerspectiveSortBy {
  CREATED_AT
  UPDATED_AT
}

# Perspective type
type CategorizedRating {
  category: String!
  rating: Int!
}

type Perspective {
  id: ID!
  userID: ID!
  user: User
  contentID: ID
  content: Content
  quality: Int
  agreement: Int
  importance: Int
  confidence: Int
  like: String
  privacy: Privacy!
  description: String
  category: String
  reviewStatus: ReviewStatus
  parts: [Int!]
  labels: [String!]
  categorizedRatings: [CategorizedRating!]
  createdAt: String!
  updatedAt: String!
}

type PaginatedPerspectives {
  items: [Perspective!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type Content {
  id: ID!
  name: String!
  url: String
  contentType: String!
  addedByUserID: ID!
  addedBy: User
  length: Int
  lengthUnits: String
  viewCount: Int
  likeCount: Int
  commentCount: Int
  channelTitle: String
  publishedAt: String
  tags: [String!]
  description: String
  response: JSON
  createdAt: String!
  updatedAt: String!
}

# Pagination types
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PaginatedContent {
  items: [Content!]!
  pageInfo: PageInfo!
  totalCount: Int
}

# Sorting enums
enum ContentSortBy {
  CREATED_AT
  UPDATED_AT
  NAME
  VIEW_COUNT
  LIKE_COUNT
  PUBLISHED_AT
}

enum SortOrder {
  ASC
  DESC
}

enum ContentType {
  YOUTUBE
}

# Inputs
input CreateContentFromYouTubeInput {
  url: String!
}

# TODO: Add additional filters (e.g., dateRange, search) or make filters dynamic
input ContentFilter {
  contentType: ContentType
  minLengthSeconds: Int
  maxLengthSeconds: Int
  search: String
}

# User inputs
input CreateUserInput {
  username: String!
  email: String
}

input UpdateUserInput {
  id: IntID!
  username: String
  email: String
}

# Perspective inputs
input CategorizedRatingInput {
  category: String!
  rating: Int!
}

input CreatePerspectiveInput {
  userID: IntID!
  contentID: IntID
  quality: Int
  agreement: Int
  importance: Int
  confidence: Int
  like: String
  privacy: Privacy
  description: String
  category: String
  parts: [Int!]
  labels: [String!]
  categorizedRatings: [CategorizedRatingInput!]
}

input UpdatePerspectiveInput {
  id: IntID!
  contentID: IntID
  quality: Int
  agreement: Int
  importance: Int
  confidence: Int
  like: String
  privacy: Privacy
  description: String
  category: String
  reviewStatus: ReviewStatus
  parts: [Int!]
  labels: [String!]
  categorizedRatings: [CategorizedRatingInput!]
}

input PerspectiveFilter {
  userID: IntID
  contentID: IntID
  privacy: Privacy
}

type Mutation {
  createContentFromYouTube(input: CreateContentFromYouTubeInput!): Content!

  # User mutations
  createUser(input: CreateUserInput!): User!
  updateUser(input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!

  # Perspective mutations
  createPerspective(input: CreatePerspectiveInput!): Perspective!
  updatePerspective(input: UpdatePerspectiveInput!): Perspective!
  deletePerspective(id: ID!): Boolean!
}

type Query {
  # Get single content by ID
  contentByID(id: ID!): Content

  # Paginated content list with optional filtering
  content(
    first: Int = 10
    after: String
    last: Int
    before: String
    sortBy: ContentSortBy = CREATED_AT
    sortOrder: SortOrder = DESC
    includeTotalCount: Boolean = false
    filter: ContentFilter
  ): PaginatedContent!

  # User queries
  userByID(id: ID!): User
  userByUsername(username: String!): User
  users: [User!]!

  # Perspective queries
  perspectiveByID(id: ID!): Perspective
  perspectives(
    first: Int = 10
    after: String
    last: Int
    before: String
    sortBy: PerspectiveSortBy = CREATED_AT
    sortOrder: SortOrder = DESC
    includeTotalCount: Boolean = false
    filter: PerspectiveFilter
  ): PaginatedPerspectives!
}
