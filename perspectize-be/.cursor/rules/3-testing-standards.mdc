---
description: Standards for Tests and Test Setup
appliesTo:
  - "**/*_test.go"
  - "**/test/**"
---
# Testing Standards

## Core Principle: Test Production Code

Tests must test the **actual production code**, NOT a replication or imitation of production code.

### ✅ Good - Tests Real Files
```go
// Tests the actual config.example.json from the project
cfg, err := config.Load("../../config/config.example.json")
assert.Equal(t, 8080, cfg.Server.Port)
```

### ❌ Bad - Tests Fake Data
```go
// Creates fake config data inline - doesn't test real config file
configContent := `{ "server": { "port": 8080 } }`
cfg, err := config.Load(tempFile)
```

**Why this matters:**
- Catches breaking changes to real configuration files
- Tests verify production files actually work
- Tests document what real config should contain
- No drift between test data and reality

### Exceptions: Use Test Data For

- Invalid inputs (malformed JSON, etc.)
- Error conditions
- Edge cases that don't exist in production files
- External API responses (mock YouTube API responses)

### Test Organization

**Unit tests** - Fast, use mocks for external dependencies:
```go
func TestRepository_GetByID(t *testing.T) {
    mockDB, mock, _ := sqlmock.New()
    // Test repository logic
}
```

**Integration tests** - Slower, use real dependencies:
```go
// +build integration
func TestRepository_Integration(t *testing.T) {
    db := setupRealPostgres(t)
    // Test against real database
}
```

### Coverage

- Aim for 70-80% overall coverage
- Focus on critical paths and business logic
- Don't chase 100% - quality over metrics

### Test Independence (FOR NOW)

Each test runs in isolation:
```go
func TestFeature(t *testing.T) {
    // Setup own data
    user := createTestUser(t)

    // Cleanup after
    t.Cleanup(func() {
        deleteUser(user.ID)
    })
}
```
