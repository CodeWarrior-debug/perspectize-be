package resolvers

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/yourorg/perspectize-go/internal/adapters/graphql/generated"
	"github.com/yourorg/perspectize-go/internal/adapters/graphql/model"
	"github.com/yourorg/perspectize-go/internal/adapters/youtube"
	"github.com/yourorg/perspectize-go/internal/core/domain"
)

// CreateContentFromYouTube is the resolver for the createContentFromYouTube field.
func (r *mutationResolver) CreateContentFromYouTube(ctx context.Context, input model.CreateContentFromYouTubeInput) (*model.Content, error) {
	content, err := r.ContentService.CreateFromYouTube(ctx, input.URL, youtube.ExtractVideoID)
	if err != nil {
		if errors.Is(err, domain.ErrAlreadyExists) {
			return nil, fmt.Errorf("content already exists for this URL")
		}
		if errors.Is(err, domain.ErrInvalidURL) {
			return nil, fmt.Errorf("invalid YouTube URL")
		}
		return nil, fmt.Errorf("failed to create content: %w", err)
	}

	return domainToModel(content), nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	user, err := r.UserService.Create(ctx, input.Username, input.Email)
	if err != nil {
		if errors.Is(err, domain.ErrAlreadyExists) {
			return nil, fmt.Errorf("user already exists: %w", err)
		}
		if errors.Is(err, domain.ErrInvalidInput) {
			return nil, fmt.Errorf("invalid input: %w", err)
		}
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	return userDomainToModel(user), nil
}

// ContentByID is the resolver for the contentByID field.
func (r *queryResolver) ContentByID(ctx context.Context, id string) (*model.Content, error) {
	intID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid content ID: %s", id)
	}

	content, err := r.ContentService.GetByID(ctx, intID)
	if err != nil {
		if errors.Is(err, domain.ErrNotFound) {
			return nil, fmt.Errorf("content not found with ID: %s", id)
		}
		if errors.Is(err, domain.ErrInvalidInput) {
			return nil, fmt.Errorf("invalid content ID: %s", id)
		}
		return nil, fmt.Errorf("failed to get content: %w", err)
	}

	return domainToModel(content), nil
}

// Content is the resolver for the content field.
func (r *queryResolver) Content(ctx context.Context, first *int, after *string, last *int, before *string, sortBy *model.ContentSortBy, sortOrder *model.SortOrder, includeTotalCount *bool, filter *model.ContentFilter) (*model.PaginatedContent, error) {
	params := domain.ContentListParams{
		First:  first,
		After:  after,
		Last:   last,
		Before: before,
	}

	// Map GraphQL enums to domain enums
	if sortBy != nil {
		switch *sortBy {
		case model.ContentSortByUpdatedAt:
			params.SortBy = domain.ContentSortByUpdatedAt
		case model.ContentSortByName:
			params.SortBy = domain.ContentSortByName
		default:
			params.SortBy = domain.ContentSortByCreatedAt
		}
	} else {
		params.SortBy = domain.ContentSortByCreatedAt
	}

	if sortOrder != nil {
		switch *sortOrder {
		case model.SortOrderAsc:
			params.SortOrder = domain.SortOrderAsc
		default:
			params.SortOrder = domain.SortOrderDesc
		}
	} else {
		params.SortOrder = domain.SortOrderDesc
	}

	if includeTotalCount != nil {
		params.IncludeTotalCount = *includeTotalCount
	}

	// Map filter
	if filter != nil {
		params.Filter = &domain.ContentFilter{}
		if filter.ContentType != nil {
			// GraphQL enum is uppercase (YOUTUBE), domain is lowercase (youtube)
			ct := domain.ContentType(strings.ToLower(string(*filter.ContentType)))
			params.Filter.ContentType = &ct
		}
		params.Filter.MinLengthSeconds = filter.MinLengthSeconds
		params.Filter.MaxLengthSeconds = filter.MaxLengthSeconds
	}

	result, err := r.ContentService.ListContent(ctx, params)
	if err != nil {
		if errors.Is(err, domain.ErrInvalidInput) {
			return nil, fmt.Errorf("invalid pagination parameters: %w", err)
		}
		return nil, fmt.Errorf("failed to list content: %w", err)
	}

	// Map domain result to GraphQL model
	items := make([]*model.Content, len(result.Items))
	for i, item := range result.Items {
		items[i] = domainToModel(item)
	}

	conn := &model.PaginatedContent{
		Items: items,
		PageInfo: &model.PageInfo{
			HasNextPage:     result.HasNext,
			HasPreviousPage: result.HasPrev,
			StartCursor:     result.StartCursor,
			EndCursor:       result.EndCursor,
		},
		TotalCount: result.TotalCount,
	}

	return conn, nil
}

// UserByID is the resolver for the userByID field.
func (r *queryResolver) UserByID(ctx context.Context, id string) (*model.User, error) {
	intID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %s", id)
	}

	user, err := r.UserService.GetByID(ctx, intID)
	if err != nil {
		if errors.Is(err, domain.ErrNotFound) {
			return nil, nil // Return null for not found (GraphQL convention)
		}
		if errors.Is(err, domain.ErrInvalidInput) {
			return nil, fmt.Errorf("invalid user ID: %s", id)
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	return userDomainToModel(user), nil
}

// UserByUsername is the resolver for the userByUsername field.
func (r *queryResolver) UserByUsername(ctx context.Context, username string) (*model.User, error) {
	user, err := r.UserService.GetByUsername(ctx, username)
	if err != nil {
		if errors.Is(err, domain.ErrNotFound) {
			return nil, nil // Return null for not found (GraphQL convention)
		}
		if errors.Is(err, domain.ErrInvalidInput) {
			return nil, fmt.Errorf("invalid username")
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	return userDomainToModel(user), nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
